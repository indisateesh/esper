<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Esper Adapters</title><link rel="stylesheet" href="../shared/css/html.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.65.1"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="book" lang="en"><div class="titlepage"><div><div><h1 class="title"><a name="d0e1"></a>Esper Adapters</h1></div><div><h2 class="subtitle">Esper Adapter Reference Documentation</h2></div><div><p class="releaseinfo">1.12.0</p></div></div><div></div><hr></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="preface"><a href="#preface">Preface</a></span></dt><dt><span class="chapter"><a href="#adapter_overview">1. Adapter Overview</a></span></dt><dd><dl><dt><span class="sect1"><a href="#adapter-shared">1.1. Adapter Library Classes</a></span></dt><dd><dl><dt><span class="sect2"><a href="#adapter-inputadapter">1.1.1. The Adapter Interface</a></span></dt><dt><span class="sect2"><a href="#adapter-inputsource">1.1.2. Using AdapterInputSource</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#adapter_csv">2. The CSV Input Adapter</a></span></dt><dd><dl><dt><span class="sect1"><a href="#csv-intro">2.1. Introduction</a></span></dt><dt><span class="sect1"><a href="#csv-step-1">2.2. Playback of CSV-formatted Events</a></span></dt><dt><span class="sect1"><a href="#csv-step-2">2.3. CSV Playback Options</a></span></dt><dt><span class="sect1"><a href="#csv-step-3">2.4. Simulating Multiple Event Streams</a></span></dt><dt><span class="sect1"><a href="#csv-step-4">2.5. Pausing and Resuming Operation</a></span></dt></dl></dd><dt><span class="chapter"><a href="#adapter_jms_spring">3. The Spring JMS Input and Output Adapters</a></span></dt><dd><dl><dt><span class="sect1"><a href="#jms-spring-intro">3.1. Introduction</a></span></dt><dt><span class="sect1"><a href="#jms-spring-engine-config">3.2. Engine Configuration</a></span></dt><dt><span class="sect1"><a href="#jms-spring-input-config">3.3. Input Adapter</a></span></dt><dd><dl><dt><span class="sect2"><a href="#jms-spring-input-config-file">3.3.1. Spring Configuration</a></span></dt><dt><span class="sect2"><a href="#jms-spring-input-unmarshal">3.3.2. JMS Message Unmarshalling</a></span></dt></dl></dd><dt><span class="sect1"><a href="#jms-spring-output-config">3.4. Output Adapter</a></span></dt><dd><dl><dt><span class="sect2"><a href="#jms-spring-output-config-file">3.4.1. Spring Configuration</a></span></dt><dt><span class="sect2"><a href="#jms-spring-output-marshal">3.4.2. JMS Message Marshalling</a></span></dt></dl></dd></dl></dd></dl></div><div class="preface" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="preface"></a>Preface</h2></div></div><div></div></div><p>
			This document describes input and output adapters for the Esper Java event stream and complex event processor.
        </p><p>
			If you are new to Esper, the Esper reference manual should be your first stop.
		</p><p>
			If you are looking for information on a specific adapter, you are at the right spot.
		</p></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="adapter_overview"></a>Chapter&nbsp;1.&nbsp;Adapter Overview</h2></div></div><div></div></div><p>
        Input and output adapters to Esper provide the means of accepting events from various sources, and for making available events to destinations.
    </p><p>
        The following input and output adapters exist:
    </p><div class="table"><a name="adapter-available"></a><p class="title"><b>Table&nbsp;1.1.&nbsp;Input and Output Adapters</b></p><table summary="Input and Output Adapters" border="1"><colgroup><col><col></colgroup><thead><tr><th>Adapter</th><th>Description</th></tr></thead><tbody><tr><td>CSV Input Adapter</td><td><p>
							The CSV input adapter can read one or more CSV-formatted input sources, transform the textual values into events, and play the events into the engine. The adapter also makes it possible to run complete simulations of events arriving in time-order from different input streams.
						</p></td></tr><tr><td>Spring JMS Input and Output Adapter</td><td><p>
							JMS adapters based on the JmsTemplate offered by Spring 2. Provides unmarshalling of JMS <tt class="literal">javax.jms.Message</tt> messages for sending into an engine instance, and marshaling of <tt class="literal">net.esper.EventBean</tt> events into JMS messages.
						</p></td></tr></tbody></table></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="adapter-shared"></a>1.1.&nbsp;Adapter Library Classes</h2></div></div><div></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="adapter-inputadapter"></a>1.1.1.&nbsp;The Adapter Interface</h3></div></div><div></div></div><p>
					The <tt class="literal">Adapter</tt> interface allows client applications to control the state of an input and output adapter. It provides state transition methods that each
					input and output adapter implements. 
			</p><p>
					An input or output adapter is always in one of the following states:
			</p><div class="itemizedlist"><ul type="disc" compact><li><p>
						Opened - The begin state; The adapter is not generating or accepting events in this state
					</p></li><li><p>
						Started - When the adapter is active, generating and accepting events
					</p></li><li><p>
						Paused - When operation of the adapter is suspended
					</p></li><li><p>
						Destroyed
					</p></li></ul></div><p>
					The state transition table below outlines adapter states and, for each state, the valid state transitions:
			</p><div class="table"><a name="adapter-states"></a><p class="title"><b>Table&nbsp;1.2.&nbsp;Adapter State Transitions</b></p><table summary="Adapter State Transitions" border="1"><colgroup><col><col><col></colgroup><thead><tr><th>Start State</th><th>Method</th><th>Next State</th></tr></thead><tbody><tr><td>Opened</td><td>start()</td><td>Started</td></tr><tr><td>Opened</td><td>destroy()</td><td>Destroyed</td></tr><tr><td>Started</td><td>stop()</td><td>Opened</td></tr><tr><td>Started</td><td>pause()</td><td>Paused</td></tr><tr><td>Started</td><td>destroy()</td><td>Destroyed</td></tr><tr><td>Paused</td><td>resume()</td><td>Started</td></tr><tr><td>Paused</td><td>stop()</td><td>Opened</td></tr><tr><td>Paused</td><td>destroy()</td><td>Destroyed</td></tr></tbody></table></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="adapter-inputsource"></a>1.1.2.&nbsp;Using AdapterInputSource</h3></div></div><div></div></div><p>
					The <tt class="literal">net.esper.adapter.AdapterInputSource</tt> encapsulates information about an input source. Input adapters use the <tt class="literal">AdapterInputSource</tt> to determine how to read input. The class provides constructors for use with different input sources:
			</p><div class="itemizedlist"><ul type="disc" compact><li><p>
						<tt class="literal">java.io.Reader</tt> to read character streams
					</p></li><li><p>
						<tt class="literal">java.io.InputStream</tt> to read byte streams
					</p></li><li><p>
						<tt class="literal">java.net.URL</tt>
					</p></li><li><p>
						Classpath resource by name
					</p></li><li><p>
						<tt class="literal">java.io.File</tt>
					</p></li></ul></div><p>
					Adapters resolve Classpath resources in the following order:
			</p><div class="orderedlist"><ol type="1" compact><li><p>
						Current thread classloader via <tt class="literal">Thread.currentThread().getContextClassLoader().getResourceAsStream</tt>
					</p></li><li><p>
						If the resource is not found: <tt class="literal">AdapterInputSource.class.getResourceAsStream</tt>
					</p></li><li><p>
						If the resource is not found: <tt class="literal">AdapterInputSource.class.getClassLoader().getResourceAsStream</tt>
					</p></li></ol></div></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="adapter_csv"></a>Chapter&nbsp;2.&nbsp;The CSV Input Adapter</h2></div></div><div></div></div><p>
        This chapter discusses the CSV input adapter. CSV is an abbreviation for comma-separated values. CSV files are simple text files in which each line
        is a comma-separated list of values. CSV-formatted text can be read from many different input sources via <tt class="literal">net.esper.adapter.AdapterInputSource</tt>.
        Please consult the JavaDoc for additional information on <tt class="literal">AdapterInputSource</tt> and the CSV adapter.
    </p><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="csv-intro"></a>2.1.&nbsp;Introduction</h2></div></div><div></div></div><p>
            In summary the CSV input adapter API performs the following functions. 
        </p><div class="itemizedlist"><ul type="disc" compact><li><p>
					Read events from an input source providing CSV-formatted text and send the events to an Esper engine instance
				</p><div class="itemizedlist"><ul type="circle" compact><li><p>
							Read from different types of input sources
						</p></li><li><p>
							Use a timestamp column to schedule events being sent into the engine							
						</p></li><li><p>
							Playback with options such as file looping, events per second and other options
						</p></li><li><p>
							Use the Esper engine timer thread to read the CSV file
						</p></li></ul></div></li><li><p>
					Read multiple CSV files using a timestamp column to simulate events coming from different streams
				</p></li></ul></div><p>
            The following formatting rules and restrictions apply to CSV-formatted text:
        </p><div class="itemizedlist"><ul type="disc" compact><li><p>
					Comment lines are prefixed with a single hash or pound <tt class="literal">#</tt> character
				</p></li><li><p>
					Strings are placed in double quotes, e.g. <tt class="literal">"value"</tt>
				</p></li><li><p>
					Escape rules follow common spreadsheet conventions, i.e. double quotes can be escaped via double quote
				</p></li><li><p>
					A column header is required unless a property order is defined explicitly
				</p></li><li><p>
					The value of the timestamp column, if one is given, must be in ascending order
				</p></li></ul></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="csv-step-1"></a>2.2.&nbsp;Playback of CSV-formatted Events</h2></div></div><div></div></div><p>
				The adapter reads events from a CSV input source and sends events to an engine using the class <tt class="literal">net.esper.adapter.csv.CSVInputAdapter</tt>.
        </p><p>
				The below code snippet reads the CSV-formatted text file "simulation.csv" expecting the file in the classpath. The <tt class="literal">AdapterInputSource</tt> class can take other input sources.
        </p><pre class="synopsis">AdapterInputSource source = new AdapterInputSource("simulation.csv");
(new CSVInputAdapter(epServiceProvider, source, "PriceEvent")).start();</pre><p>
				To use the CSVInputAdapter without any options, the event type <tt class="literal">PriceEvent</tt> and its property names and value types must be known to the engine. The next section elaborates on adapter options.
        </p><div class="itemizedlist"><ul type="disc" compact><li><p>
					Configure the engine instance for a Map-based event type
				</p></li><li><p>
					Place a header record in your CSV file that names each column as specified in the event type
				</p></li></ul></div><p>
				The sample application code below shows all the steps to configure, via API, a Map-based event type and play the CSV file without setting any of the available options.
        </p><pre class="programlisting">Map&lt;String, Class&gt; eventProperties = new HashMap&lt;String, Class&gt;();
eventProperties.put("symbol", String.class);
eventProperties.put("price", double.class);
eventProperties.put("volume", Integer.class);

Configuration configuration = new Configuration();
configuration.addEventTypeAlias("PriceEvent", eventProperties);

epService = EPServiceProviderManager.getDefaultProvider(configuration);

EPStatement stmt = epService.getEPAdministrator().createEQL(
   "select symbol, price, volume from PriceEvent.win:length(100)");

(new CSVInputAdapter(epService, new AdapterInputSource(filename), "PriceEvent")).start();</pre><p>
				The contents of a sample CSV file is shown next.
        </p><pre class="programlisting">symbol,price,volume
IBM,55.5,1000</pre><p>
				The next code snippet outlines using a <tt class="literal">java.io.Reader</tt> as an alternative input source :
        </p><pre class="programlisting">String myCSV = "symbol, price, volume" + NEW_LINE + "IBM, 10.2, 10000";
StringReader reader = new StringReader(myCSV);
(new CSVInputAdapter(epService, new AdapterInputSource(reader), "PriceEvent")).start();</pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="csv-step-2"></a>2.3.&nbsp;CSV Playback Options</h2></div></div><div></div></div><p>
				Use the <tt class="literal">CSVInputAdapterSpec</tt> class to set playback options. The following options are available:
        </p><div class="itemizedlist"><ul type="disc" compact><li><p>
					Loop - Reads the CSV input source in a loop; When the end is reached, the input adapter rewinds to the beginning
				</p></li><li><p>
					Events per second - Controls the number of events per second that the adapter sends to the engine
				</p></li><li><p>
					Property order - Controls the order of event property values in the CSV input source, for use when the CSV input source does not have a header column
				</p></li><li><p>
					Property types - Defines a new Map-based event type given a map of event property names and types. No engine configuration for the event type is required as long as the input adapter is created before statements against the event type are created.
				</p></li><li><p>
					Engine thread - Instructs the adapter to use the engine timer thread to read the CSV input source and send events to the engine
				</p></li><li><p>
					Timestamp column name - Defines the name of the timestamp column in the CSV input source; The timestamp column must carry long-typed timestamp values relative to the current time; Use zero for the current time
				</p></li></ul></div><p>
				The next code snippet shows the use of <tt class="literal">CSVInputAdapterSpec</tt> to set playback options.
        </p><pre class="programlisting">CSVInputAdapterSpec spec = new CSVInputAdapterSpec(new AdapterInputSource(myURL), "PriceEvent");
spec.setEventsPerSec(1000);
spec.setLooping(true);
  
InputAdapter inputAdapter = new CSVInputAdapter(epService, spec);
inputAdapter.start();	// method blocks unless engine thread option is set</pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="csv-step-3"></a>2.4.&nbsp;Simulating Multiple Event Streams</h2></div></div><div></div></div><p>
				The CSV input adapter can run simulations of events arriving in time-order from different input streams. Use the <tt class="literal">AdapterCoordinator</tt> as a specialized input adapter for coordinating multiple CSV input sources by timestamp.
        </p><p>
				The sample application code listed below simulates price and trade events arriving in timestamp order. Via the adapter the application reads two CSV-formatted files from a URL that each contain a timestamp column as well as price or trade events. The <tt class="literal">AdapterCoordinator</tt> uses the timestamp column to send events to the engine in the exact ordering prescribed by the timestamp values.
        </p><pre class="programlisting">AdapterInputSource sourceOne = new AdapterInputSource(new URL("FILE://prices.csv"));
CSVInputAdapterSpec inputOne = new CSVInputAdapterSpec(sourceOne, "PriceEvent");
inputOne.setTimestampColumn("timestamp");

AdapterInputSource sourceTwo = new AdapterInputSource(new URL("FILE://trades.csv"));
CSVInputAdapterSpec inputTwo = new CSVInputAdapterSpec(sourceTwo, "TradeEvent");
inputTwo.setTimestampColumn("timestamp");

AdapterCoordinator coordinator = new AdapterCoordinatorImpl(epService, true);
coordinator.coordinate(new CSVInputAdapter(inputOne));
coordinator.coordinate(new CSVInputAdapter(inputTwo));
coordinator.start();</pre><p>
				The <tt class="literal">AdapterCoordinatorImpl</tt> is provided with two parameters: the engine instance, and a boolean value 
				that instructs the adapter to use the engine timer thread if set to true, and the adapter can use the application thread if the flag passed is false.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="csv-step-4"></a>2.5.&nbsp;Pausing and Resuming Operation</h2></div></div><div></div></div><p>
				The CSV adapter can employ the engine timer thread of an Esper engine instance to read and send events. This can be controlled via the <tt class="literal">setUsingEngineThread</tt> method on <tt class="literal">CSVInputAdapterSpec</tt>. We use that feature in the sample code below to pause and resume a running CSV input adapter.
        </p><pre class="programlisting">CSVInputAdapterSpec spec = new CSVInputAdapterSpec(new AdapterInputSource(myURL), "PriceEvent");
spec.setEventsPerSec(100);
spec.setUsingEngineThread(true);
  
InputAdapter inputAdapter = new CSVInputAdapter(epService, spec);
inputAdapter.start();	// method starts adapter and returns, non-blocking
Thread.sleep(5000);	// sleep 5 seconds
inputAdapter.pause();
Thread.sleep(5000);	// sleep 5 seconds
inputAdapter.resume();
Thread.sleep(5000);	// sleep 5 seconds
inputAdapter.stop();</pre></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="adapter_jms_spring"></a>Chapter&nbsp;3.&nbsp;The Spring JMS Input and Output Adapters</h2></div></div><div></div></div><p>
        This chapter discusses the input and output adapters for JMS based on the Spring JmsTemplate technology. For more information on Spring, and the latest version of Spring, please visit <a href="http://www.springframework.org" target="_top">http://www.springframework.org</a>
    </p><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="jms-spring-intro"></a>3.1.&nbsp;Introduction</h2></div></div><div></div></div><p>
			Here are the steps to use the adapters:
		</p><div class="orderedlist"><ol type="1" compact><li><p>
					Configure an Esper engine instance to use a <tt class="literal">SpringContextLoader</tt> for loading input and output adapters, and point it to a Spring JmsTemplate configuration file.
				</p></li><li><p>
					Create a Spring JmsTemplate configuration file for your JMS provider and add all your input and output adapter entries in the same file.
				</p></li><li><p>
					For receiving events from a JMS destination into an engine (input adapter):
				</p><div class="orderedlist"><ol type="a" compact><li><p>
							List the destination and un-marshalling class in the Spring configuration. 
						</p></li><li><p>
							Create EQL statements using the event type alias matching the event objects or the Map-event type aliases received.
						</p></li></ol></div></li><li><p>
					For sending events to a JMS destination (output adapter):
				</p><div class="orderedlist"><ol type="a" compact><li><p>
							Use the <tt class="literal">insert-into</tt> syntax naming the stream to insert-into using the same name as listed in the Spring configuration file
						</p></li><li><p>
							Configure the Map event type of the stream in the engine configuration
						</p></li></ol></div></li></ol></div><p>
            In summary the Spring JMS input adapter performs the following functions:
        </p><div class="itemizedlist"><ul type="disc" compact><li><p>
					Initialize from a given Spring configuration file in classpath or from a filename. The Spring configuration file sets all JMS parameters such as JMS connection factory, destination and listener pools.
				</p></li><li><p>
					Attach to a JMS destination and listen to messages using the Spring class <tt class="literal">org.springframework.jms.core.JmsTemplate</tt>
				</p></li><li><p>
					Unmarshal a JMS message and send into the configured engine instance
				</p></li></ul></div><p>
            The Spring JMS output adapter can:
        </p><div class="itemizedlist"><ul type="disc" compact><li><p>
					Initialize from a given Spring configuration file in classpath or from a filename, and attach to a JMS destination
				</p></li><li><p>
					Act as a listener to one or more named streams populated via <tt class="literal">insert-into</tt> syntax by EQL statements
				</p></li><li><p>
					Marshal events generated by a stream into a JMS message, and send to the given destination
				</p></li></ul></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="jms-spring-engine-config"></a>3.2.&nbsp;Engine Configuration</h2></div></div><div></div></div><p>
            The Spring JMS input and output adapters are configured as part of the Esper engine configuration. EsperIO supplies a <tt class="literal">SpringContextLoader</tt> class that loads a Spring
            configuration file which in turn configures the JMS input and output adapters. List the <tt class="literal">SpringContextLoader</tt> class as an adapter loader in the Esper configuration file as the below example shows. The configuration API can alternatively be used to configure one or more adapter loaders.
        </p><pre class="programlisting">&lt;esper-configuration&gt;

  &lt;!-- Sample configuration for an input/output adapter loader --&gt;
  &lt;adapter-loader name="MyLoader" class-name="net.esper.adapter.SpringContextLoader"&gt;
    &lt;!-- SpringApplicationContext translates into Spring ClassPathXmlApplicationContext 
           or FileSystemXmlApplicationContext. Only one app-context of a sort can be used. 
           When both attributes are used classpath and file, classpath prevails --&gt;
    &lt;init-arg name="classpath-app-context" value="spring\jms-spring.xml" /&gt;
    &lt;init-arg name="file-app-context" value="spring\jms-spring.xml" /&gt;
  &lt;/adapter-loader&gt;

&lt;/esper-configuration&gt;</pre><p>
            The loader loads the Spring configuration file from classpath via the <tt class="literal">classpath-app-context</tt> configuration, or from a file via <tt class="literal">file-app-context</tt>.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="jms-spring-input-config"></a>3.3.&nbsp;Input Adapter</h2></div></div><div></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jms-spring-input-config-file"></a>3.3.1.&nbsp;Spring Configuration</h3></div></div><div></div></div><p>
				The Spring configuration file must list input and output adapters to be initialized by <tt class="literal">SpringContextLoader</tt> upon engine initialization.
				Please refer to your JMS provider documentation, and the Spring framework documentation on help to configure your specific JMS provider via Spring.
			</p><p>
				The next XML snippet shows a complete sample configuration for an input adapter. The sample includes the JMS configuration for an Apache ActiveMQ JMS provider.
			</p><pre class="programlisting">&lt;!-- Spring Application Context --&gt;
&lt;beans default-destroy-method="destroy"&gt;

  &lt;!-- JMS ActiveMQ Connection Factory --&gt;
  &lt;bean id="jmsActiveMQFactory" class="org.apache.activemq.pool.PooledConnectionFactory"&gt;
    &lt;property name="connectionFactory"&gt;
      &lt;bean class="org.apache.activemq.ActiveMQConnectionFactory"&gt;
        &lt;property name="brokerURL" value="tcp://localhost:61616"/&gt;
      &lt;/bean&gt;
    &lt;/property&gt;
  &lt;/bean&gt;

  &lt;!--  ActiveMQ destination to use  by default --&gt;
  &lt;bean id="defaultDestination"
        class="org.apache.activemq.command.ActiveMQQueue"&gt;
    &lt;constructor-arg value="ESPER.QUEUE"/&gt;
  &lt;/bean&gt;

  &lt;!--  Spring JMS Template for ActiveMQ --&gt;
  &lt;bean id="jmsActiveMQTemplate" class="org.springframework.jms.core.JmsTemplate"&gt;
    &lt;property name="connectionFactory"&gt;
      &lt;ref bean="jmsActiveMQFactory"/&gt;
    &lt;/property&gt;
    &lt;property name="defaultDestination"&gt;
      &lt;ref bean="defaultDestination"/&gt;
    &lt;/property&gt;
  &lt;/bean&gt;

  &lt;!-- Provides listener threads --&gt;
  &lt;bean id="listenerContainer" 
              class="org.springframework.jms.listener.SimpleMessageListenerContainer"&gt;
    &lt;property name="connectionFactory" ref="jmsActiveMQFactory"/&gt;
    &lt;property name="destination" ref="defaultDestination"/&gt;
    &lt;property name="messageListener" ref="jmsInputAdapter"/&gt;
  &lt;/bean&gt;

  &lt;!-- Default unmarshaller --&gt;
  &lt;bean id="jmsMessageUnmarshaller" 
              class="net.esper.adapter.jms.JMSDefaultAnyMessageUnmarshaller"/&gt;

  &lt;!-- Input adapter --&gt;
  &lt;bean id="jmsInputAdapter" class="net.esper.adapter.jms.SpringJMSTemplateInputAdapter"&gt;
    &lt;property name="jmsTemplate"&gt;
      &lt;ref bean="jmsActiveMQTemplate"/&gt;
    &lt;/property&gt;
    &lt;property name="jmsMessageUnmarshaller"&gt;
      &lt;ref bean="jmsMessageUnmarshaller"/&gt;
    &lt;/property&gt;
  &lt;/bean&gt;

&lt;/beans&gt;</pre><p>
				This input adapter attaches to the JMS destination <tt class="literal">ESPER.QUEUE</tt> at an Apache MQ broker available at port <tt class="literal">tcp://localhost:61616</tt>. It configures an un-marshalling class as discussed next.
			</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jms-spring-input-unmarshal"></a>3.3.2.&nbsp;JMS Message Unmarshalling</h3></div></div><div></div></div><p>
				EsperIO provides a class for unmarshaling JMS message instances into events for processing by an engine in the class <tt class="literal">JMSDefaultAnyMessageUnmarshaller</tt>. The class unmarshals as follows:
			</p><div class="itemizedlist"><ul type="disc" compact><li><p>
						If the received Message is of type <tt class="literal">javax.xml.MapMessage</tt>, extract the event type alias out of the message and send to the engine via <tt class="literal">sendEvent(alias, Map)</tt> 
					</p></li><li><p>
						If the received Message is of type <tt class="literal">javax.xml.ObjectMessage</tt>, extract the <tt class="literal">Serializable</tt> out of the message and send to the engine via <tt class="literal">sendEvent(Object)</tt>
					</p></li><li><p>
						Else the un-marshaller outputs a warning and ignores the message
					</p></li></ul></div><p>
				The unmarshaller must be made aware of the event type of events within <tt class="literal">MapMessage</tt> messages. This is achieved by the client application setting a well-defined property on the message: <tt class="literal">InputAdapter.ESPERIO_MAP_EVENT_TYPE</tt>.  An example code snippet is:
			</p><pre class="programlisting">MapMessage mapMessage = jmsSession.createMapMessage();
mapMessage.setObject(InputAdapter.ESPERIO_MAP_EVENT_TYPE, "MyInputEvent");</pre></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="jms-spring-output-config"></a>3.4.&nbsp;Output Adapter</h2></div></div><div></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jms-spring-output-config-file"></a>3.4.1.&nbsp;Spring Configuration</h3></div></div><div></div></div><p>
				The Spring configuration file lists all input and output adapters in one file. The <tt class="literal">SpringContextLoader</tt> upon engine initialization starts all input and output adapters.
			</p><p>
				The next XML snippet shows a complete sample configuration of an output adapter. Please check with your JMS provider for the appropriate Spring class names and settings. Note that the input and output adapter Spring configurations can be in the same file.
			</p><pre class="programlisting">
&lt;!-- Application Context --&gt;
&lt;beans default-destroy-method="destroy"&gt;

  &lt;!-- JMS ActiveMQ Connection Factory --&gt;
  &lt;bean id="jmsActiveMQFactory" class="org.apache.activemq.pool.PooledConnectionFactory"&gt;
    &lt;property name="connectionFactory"&gt;
      &lt;bean class="org.apache.activemq.ActiveMQConnectionFactory"&gt;
        &lt;property name="brokerURL" value="tcp://localhost:61616"/&gt;
      &lt;/bean&gt;
    &lt;/property&gt;
  &lt;/bean&gt;

  &lt;!--  ActiveMQ destination to use  by default --&gt;
  &lt;bean id="defaultDestination"
        class="org.apache.activemq.command.ActiveMQQueue"&gt;
    &lt;constructor-arg value="ESPER.QUEUE"/&gt;
  &lt;/bean&gt;

  &lt;!--  Spring JMS Template for ActiveMQ --&gt;
  &lt;bean id="jmsActiveMQTemplate" class="org.springframework.jms.core.JmsTemplate"&gt;
    &lt;property name="connectionFactory"&gt;
      &lt;ref bean="jmsActiveMQFactory"/&gt;
    &lt;/property&gt;
    &lt;property name="defaultDestination"&gt;
      &lt;ref bean="defaultDestination"/&gt;
    &lt;/property&gt;
    &lt;property name="receiveTimeout"&gt;
      &lt;value&gt;30000&lt;/value&gt;
    &lt;/property&gt;
  &lt;/bean&gt;

  &lt;!--  Marshaller marshals events into map messages --&gt;
  &lt;bean id="jmsMessageMarshaller" class="net.esper.adapter.jms.JMSDefaultMapMessageMarshaller"/&gt;
  &lt;bean id="myCustomMarshaller" class="net.esper.adapter.jms.JMSDefaultMapMessageMarshaller"/&gt;

  &lt;!--  Output adapter puts it all together --&gt;
  &lt;bean id="jmsOutputAdapter" class="net.esper.adapter.jms.SpringJMSTemplateOutputAdapter"&gt;
    &lt;property name="jmsTemplate"&gt;
      &lt;ref bean="jmsActiveMQTemplate"/&gt;
    &lt;/property&gt;
    &lt;property name="subscriptionMap"&gt;
      &lt;map&gt;
        &lt;entry&gt;
          &lt;key&gt;&lt;idref local="subscriptionOne"/&gt;&lt;/key&gt;
          &lt;ref bean="subscriptionOne"/&gt;
        &lt;/entry&gt;
        &lt;entry&gt;
          &lt;key&gt;&lt;idref local="subscriptionTwo"/&gt;&lt;/key&gt;
          &lt;ref bean="subscriptionTwo"/&gt;
        &lt;/entry&gt;
      &lt;/map&gt;
    &lt;/property&gt;
    &lt;property name="jmsMessageMarshaller"&gt;
      &lt;ref bean="jmsMessageMarshaller"/&gt;
    &lt;/property&gt;
  &lt;/bean&gt;

  &lt;bean id="subscriptionOne" class="net.esper.adapter.jms.JMSSubscription"&gt;
    &lt;property name="eventTypeAlias" value="MyOutputStream"/&gt;
  &lt;/bean&gt;

  &lt;bean id="subscriptionTwo" class="net.esper.adapter.jms.JMSSubscription"&gt;
    &lt;property name="eventTypeAlias" value="MyOtherOutputStream"/&gt;
    &lt;property name="jmsMessageMarshaller"&gt;
      &lt;ref bean="myCustomMarshaller"/&gt;
    &lt;/property&gt;
  &lt;/bean&gt;

&lt;/beans&gt;</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jms-spring-output-marshal"></a>3.4.2.&nbsp;JMS Message Marshalling</h3></div></div><div></div></div><p>
				EsperIO provides a marshal implementation in the class <tt class="literal">JMSDefaultMapMessageMarshaller</tt>. This marshaller constructs a JMS <tt class="literal">MapMessage</tt> from any event received by copying 
				event properties into the name-value pairs of the message. The configuration file makes it easy to configure a custom marshaller that adheres to the <tt class="literal">net.esper.adapter.jms.JMSMessageMarshaller</tt> interface.
			</p><p>
                Note that this marshaller uses <tt class="literal">javax.jms.MapMessage</tt> name-value pairs and not general <tt class="literal">javax.jms.Message</tt> properties.
                This means when you'll read the event properties back from the JMS MapMessage, you will have to use the <tt class="literal">javax.jms.MapMessage.getObject(...)</tt> method.
            </p><p>
				The <tt class="literal">SpringJMSTemplateOutputAdapter</tt> is configured with a list of subscription instances of type <tt class="literal">JMSSubscription</tt> as the sample configuration shows. Each subscription defines 
				an event type alias that must be configured and used in the <tt class="literal">insert-into</tt> syntax of a statement.
			</p><p>
				To connect the Spring JMS output adapter and the EQL statements producing events, use the <tt class="literal">insert-into</tt> syntax to direct events for output.  Here is a sample statement that sends events into <tt class="literal">MyOutputStream</tt>:
			</p><pre class="programlisting">insert into MyOutputStream select assetId, zone from RFIDEvent</pre><p>
				The type <tt class="literal">MyOutputStream</tt> must be known to an engine instance. The output adapter requires the alias to be configured with the Engine instance, e.g.:
			</p><pre class="programlisting">&lt;esper-configuration&gt;
  &lt;event-type alias="MyOutputStream"&gt;
    &lt;java-util-map&gt;
      &lt;map-property name="assetId" class="String"/&gt;
      &lt;map-property name="zone" class="int"/&gt;
    &lt;/java-util-map&gt;
  &lt;/event-type&gt;
&lt;/esper-configuration&gt;</pre></div></div></div></div><script xmlns="http://www.w3.org/TR/xhtml1/transitional" src="http://www.google-analytics.com/urchin.js" type="text/javascript"></script><script xmlns="http://www.w3.org/TR/xhtml1/transitional" type="text/javascript">
	_uacct = "UA-1261295-1";
	urchinTracker();
	</script></body></html>