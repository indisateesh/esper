Two Minute Tutorial
~~~~~~~~~~~~~~

  Esper offers two principal method of event processing:
  
  [[1]] Event pattern matching
  
  [[2]] Event stream analysis
  
  []
  
  
  Events are represented as JavaBean instances. Esper can interrogate any POJOs representing events as long as the required getter methods are exposed.
  

* Event Pattern Matching

	Event patterns match when an event or multiple events occur that match the pattern's definition. Patterns can also be temporal (time-based).
	Pattern matching is implemented via state machines. 

	Pattern expressions can consist of filter expressions combined with pattern operators. Expressions can contain further nested
	pattern expressions by including the nested expression(s) in round brackets.

	There are 5 types of operators:
	
	[[1]] Operators that control pattern finder creation and termination: <every>
	
	[[2]] Logical operators: <and, or, not>
	
	[[3]] Temporal operators that operate on event order: < -\> (followed-by) >
	
	[[4]] Guards are where-conditions that filter out events and cause termination of the pattern finder, such as <timer:within>
	
	[[5]] Observers observe time events as well as other events, such as <timer:interval, timer:at>
	
	[]
	
	
	A sample pattern that alerts on each IBM stock tick with a price greater then 80 and within the next 60 seconds:
	
----------------------------------------
  every com.mypackage.StockTickEvent(symbol="IBM", price>80) where timer:within(60)
----------------------------------------	

	A sample pattern that alerts every 5 minutes past the hour:
	
----------------------------------------
  every timer:at(5, *, *, *, *)
----------------------------------------	

	A sample pattern that alerts when event A occurs, followed by either event B or event C:
	
----------------------------------------
  A -> ( B or C )
----------------------------------------	

	An event pattern where a property of a following event must match a property from the first event: 
 
----------------------------------------
  every a=EventX -> every b=EventY(objectID=a.objectID)
----------------------------------------

* Event Stream Analysis
	
	EQL statements are used to derive and aggregate information from one or more streams of events, and to join event streams.  
	EQL is similar to SQL in it's use of the <select> clause and the <where> clause. However EQL statements instead of tables use event streams
	and a concept called <views>. Similar to tables in an SQL statement, views define the data available for querying and filtering. 
	Views can represent windows over a stream of events. Views can also derive statistics from event properties, group events or handle unique event property values.
	
	A sample EQL statement that computes univariate statistics (average, stdev) over price for the last 30 seconds of IBM stock ticks.
	
----------------------------------------
  select * from StockTickEvent(symbol='IBM').win:time(30).stat:uni('price')
----------------------------------------	

	A sample EQL that returns symbol name and volume weighted average price (vwap) for each symbol for all 
	StockTickEvents in the last 10 minutes (600 seconds).
	
----------------------------------------
  select symbol, average as vwap
    from StockTickEvent.std:groupby(symbol).win:time(600).stat:weighted_avg('price', 'volume')
----------------------------------------	
	
	This example joins 2 event streams. The first event stream consists of fraud warning events for which we keep the last 30 minutes (1800 seconds). The second stream is withdrawal events for which we consider the last 30 seconds. The streams are joined on account number.

----------------------------------------
  select fraud.accountNumber as accntNum, fraud.warning as warn, withdraw.amount as amount,
         MAX(fraud.timestamp, withdraw.timestamp) as timestamp, 'withdrawlFraud' as desc
    from FraudWarningEvent.win:time(1800) as fraud,
         WithdrawalEvent.win:time(30) as withdraw
   where fraud.accountNumber = withdraw.accountNumber
----------------------------------------	
