Performance-Related Information
~~~~~~~~~~~~~~

	This page contains information about the Esper benchmark kit and tips for achieving the best performance for your application.
	

* The Esper Benchmark kit

	We have put a small benchmark kit together to enable you to measure and tune Esper performance 
	in your environment, and for the purpose of comparing Esper performance to the performance of other CEP/ESP solutions.
	
	The benchmark kit is described in detail in the documentation in a separate chapter on performance.
	
	We are planning to collect platform-specific data obtained by the benchmark kit on our 
	{{{http://docs.codehaus.org/display/ESPER/Home}Wiki page}}.
	
		
* Understand how to tune your Java virtual machine
	
		Esper runs on a JVM and you need to be familiar with JVM tuning.
		Key parameters to consider include minimum and maximum heap memory and nursery heap sizes.
		Statements with time-based or length-based data windows can consume large amounts of memory as their size or length can be large.
		For time-based data windows, one needs to be aware that the memory consumed depends on the actual event stream input
		throughput. Event pattern instances also consume memory, especially when using the "every"
		keyword in patterns to repeat pattern sub-expressions - which again will depend on the actual event stream input throughput.
	
* Compare Esper to other solutions in the space of complex event or event stream processing
	
		If you compare Esper performance to the performance of another solution, you need to ensure that your statements have
		truly equivalent semantics. The is because between different vendors the event processing language can be seem fairly similar 
		whoever may, for all similarities, produce different results.

		For example some vendor solution mandates the use of "bounded streams". The next statement shows one vendor's event processing syntax:
		
----------------------------------------
// Other (name omitted) vendor solution statement:
select * from (select * from Market where ticker = 'GOOG') retain 1 event
// The above is NOT an Esper statement
----------------------------------------

		The semantically equivalent statement in Esper is:
		
----------------------------------------		
// Esper statement with the same semantics:
select * from Market(ticker='$').win:length(1)
----------------------------------------		

		As an example, a NOT semantically equivalent statement in Esper is:
		
----------------------------------------		
// Esper statement that DOES ***NOT*** HAVE the same semantics 
// No length window was used
select * from Market(ticker='$')
----------------------------------------		


* Select the underlying event rather then individual fields
	
	By selecting the underlying event in the select-clause we can reduce load on the engine, since the 
	engine does not need to generate a new output event for each input event.
	
	For example, the following statement returns the underlying event to update listeners:

----------------------------------------
// Better performance
select * from RFIDEvent
----------------------------------------

	In comparison, the next statement selects individual properties. This statement requires the engine to generate an output event that 
	contains exactly the required properties:

----------------------------------------
// Less good performance
select assetId, zone, xlocation, ylocation from RFIDEvent 
----------------------------------------

* Prefer stream-level filtering over post-data-window filtering
	
	Esper stream-level filtering is very well optimized, while filtering via the where-clause post any data windows is not optimized. 
	In very simple statements that don't have data windows this distinction can make a performance difference.

	Consider the example below, which performs stream-level filtering:

----------------------------------------
// Better performance : stream-level filtering
select * from MarketData(ticker = 'GOOG')
----------------------------------------

	The example below is the equivalent (same semantics) statement and performs post-data-window filtering without a data window.
	The engine does not optimize statements that filter in the where-clause for the reason that data window views are generally present.

----------------------------------------
// Less good performance : post-data-window filtering
select * from MarketData where ticker = 'GOOG'
----------------------------------------

	Thus this optimization technique applies to statements without any data window. 
	
	When a data window is used, the semantics change. Let's look at an example to better understand the difference:
	In the next statement only GOOG market events enter the length window:
	
----------------------------------------
select avg(price) from MarketData(ticker = 'GOOG').win:length(100)
----------------------------------------

	The above statement computes the average price of GOOG market data events for the last 100 GOOG market data events. 
	
	Compare the filter position to a filter in the where clause. 
	The following statement is NOT equivalent as all events enter the data window (not just GOOG events):

----------------------------------------
select avg(price) from MarketData.win:length(100) where ticker = 'GOOG'
----------------------------------------

	The statement above computes the average price of all market data events for the last 100 market data events, and outputs results only for GOOG.
	
	
* Reduce the use of arithmetic in expressions
	
	Esper does not yet attempt to pre-evaluate arithmetic expressions that produce constant results.
	
	Therefore, a filter expression as below is optimized:

----------------------------------------
// Better performance : no arithmetic
select * from MarketData(price>40) 
----------------------------------------

	While the engine cannot currently optimize this expression:
	
----------------------------------------
// Less good performance : with arithmetic
select * from MarketData(price+10>50) 
----------------------------------------

* Consider using EventPropertyGetter for fast access to event properties
	
	The EventPropertyGetter interface is useful for obtaining an event property value without property name table lookup 
	given an EventBean instance that is of the same event type that the property getter was obtained from.
	
	When compiling a statement, the EPStatement instance lets us know the EventType via the getEventType() method.
	From the EventType we can obtain EventPropertyGetter instances for named event properties.
	
	To demonstrate, consider the following simple statement:
	
----------------------------------------
select symbol, avg(price) from MarketDataEvent group by symbol
----------------------------------------

	After compiling the statement, obtain the EventType and pass the type to the listener:

----------------------------------------
EPStatement stmt = epService.getEPAdministrator().createEQL(stmtText);
MyGetterUpdateListener listener = new MyGetterUpdateListener(stmt.getEventType());
----------------------------------------

	The listener can use the type to obtain fast getters for property values of events for the same type:
	
----------------------------------------
public class MyGetterUpdateListener implements StatementAwareUpdateListener {
    private final EventPropertyGetter symbolGetter;
    private final EventPropertyGetter avgPriceGetter;

    public MyGetterUpdateListener(EventType eventType) {
        symbolGetter = eventType.getGetter("symbol");
        avgPriceGetter = eventType.getGetter("avg(price)");
    }
----------------------------------------

	Last, the update method can invoke the getters to obtain event property values:
	
----------------------------------------
    public void update(EventBean[] eventBeans, EventBean[] oldBeans, EPStatement epStatement, EPServiceProvider epServiceProvider) {
        String symbol = (String) symbolGetter.get(eventBeans[0]);
        long volume = (Long) volumeGetter.get(eventBeans[0]);
        // some more logic here
    }
----------------------------------------

* Consider casting the underlying event

	When an application requires the value of most or all event properties, it can often be best to simply select the underlying event via wildcard
	and cast the received events.
	
	Let's look at the sample statement:
	
----------------------------------------
select * from MarketDataEvent(symbol regexp 'E[a-z]')
----------------------------------------

	An update listener to the statement may want to cast the received events to the expected underlying event class:

----------------------------------------
    public void update(EventBean[] eventBeans, EventBean[] eventBeans) {
        MarketDataEvent md = (MarketDataEvent) eventBeans[0].getUnderlying();
        // some more logic here
    }
----------------------------------------
	
* Turns off logging

	Since Esper 1.10, even if you don't have a log4j configuration file in place, Esper will make sure to minimize execution path logging overhead.
	For prior versions, and to reduce logging overhead overall, we recommend the "WARN" log level or the "INFO" log level.
	
	Please see the log4j configuration file in "etc/infoonly_log4j.xml" for example log4j settings.
