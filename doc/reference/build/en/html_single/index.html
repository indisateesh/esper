<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Esper - Java Event Stream Processor </title><link rel="stylesheet" href="../shared/css/html.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.65.1"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="book" lang="en"><div class="titlepage"><div><div><h1 class="title"><a name="d0e1"></a>Esper - Java Event Stream Processor </h1></div><div><h2 class="subtitle">Esper Reference Documentation</h2></div><div><p class="releaseinfo">0.9.1</p></div></div><div></div><hr></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="preface"><a href="#preface">Preface</a></span></dt><dt><span class="chapter"><a href="#technology_overview">1. Technology Overview</a></span></dt><dd><dl><dt><span class="sect1"><a href="#technology_overview_intro_cep">1.1. Introduction to CEP and event stream analysis</a></span></dt><dt><span class="sect1"><a href="#cep_and_relational">1.2. CEP and relational databases</a></span></dt><dt><span class="sect1"><a href="#cep_with_esper">1.3. The Esper engine for CEP</a></span></dt></dl></dd><dt><span class="chapter"><a href="#architecture">2. Architecture</a></span></dt><dd><dl><dt><span class="sect1"><a href="#architecture-overview">2.1. Overview</a></span></dt><dt><span class="sect1"><a href="#building_testing">2.2. Building and Testing</a></span></dt></dl></dd><dt><span class="chapter"><a href="#configuration">3. Configuration</a></span></dt><dd><dl><dt><span class="sect1"><a href="#configuration-programmatic">3.1. Programmatic configuration</a></span></dt><dt><span class="sect1"><a href="#configuration-via-xml">3.2. Configuration via XML file</a></span></dt><dt><span class="sect1"><a href="#configuration-xml">3.3. XML Configuration file</a></span></dt><dt><span class="sect1"><a href="#configuration-items">3.4. Configuration items</a></span></dt><dd><dl><dt><span class="sect2"><a href="#config-event-name">3.4.1. Event type alias to Java class mapping</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#api">4. API Reference</a></span></dt><dd><dl><dt><span class="sect1"><a href="#api-reference-intro">4.1. API Overview</a></span></dt><dt><span class="sect1"><a href="#api-engine-instances">4.2. Engine Instances</a></span></dt><dt><span class="sect1"><a href="#api-administrative">4.3. The Administrative Interface</a></span></dt><dt><span class="sect1"><a href="#api-runtime">4.4. The Runtime Interface</a></span></dt><dt><span class="sect1"><a href="#api-event-class-reqs">4.5. Event Class Requirements</a></span></dt><dd><dl><dt><span class="sect2"><a href="#event-properties">4.5.1. Event Property Types</a></span></dt></dl></dd><dt><span class="sect1"><a href="#api-controlling-time">4.6. Time-Keeping Events</a></span></dt><dt><span class="sect1"><a href="#api-events-received">4.7. Events Received from the Engine</a></span></dt></dl></dd><dt><span class="chapter"><a href="#event_patterns">5. Event Pattern Reference</a></span></dt><dd><dl><dt><span class="sect1"><a href="#event-pattern-intro">5.1. Event Pattern Overview</a></span></dt><dt><span class="sect1"><a href="#pattern-how-to-use">5.2. How to use Patterns</a></span></dt><dd><dl><dt><span class="sect2"><a href="#pattern-howto-syntax">5.2.1. Pattern Syntax</a></span></dt><dt><span class="sect2"><a href="#patterns-howto-subscribe">5.2.2. Subscribing to Pattern Events</a></span></dt><dt><span class="sect2"><a href="#pattern-howto-pull-data">5.2.3. Pulling Data from Patterns</a></span></dt></dl></dd><dt><span class="sect1"><a href="#pattern-filter">5.3. Filter Expressions</a></span></dt><dt><span class="sect1"><a href="#pattern-operators">5.4. Pattern Operators</a></span></dt><dd><dl><dt><span class="sect2"><a href="#pattern-logical-every">5.4.1. Every</a></span></dt><dt><span class="sect2"><a href="#pattern-logical-and">5.4.2. And</a></span></dt><dt><span class="sect2"><a href="#pattern-logical-or">5.4.3. Or</a></span></dt><dt><span class="sect2"><a href="#pattern-logical-not">5.4.4. Not</a></span></dt><dt><span class="sect2"><a href="#pattern-temporal-followed-by">5.4.5. Followed-by</a></span></dt></dl></dd><dt><span class="sect1"><a href="#pattern-guards">5.5. Guards</a></span></dt><dd><dl><dt><span class="sect2"><a href="#pattern-timer-within">5.5.1. timer:within</a></span></dt></dl></dd><dt><span class="sect1"><a href="#pattern-observers">5.6. Pattern Observers</a></span></dt><dd><dl><dt><span class="sect2"><a href="#pattern-timer-interval">5.6.1. timer:interval</a></span></dt><dt><span class="sect2"><a href="#pattern-timer-at">5.6.2. timer:at</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#EQL">6. EQL Reference</a></span></dt><dd><dl><dt><span class="sect1"><a href="#eql-intro">6.1. EQL Introduction</a></span></dt><dt><span class="sect1"><a href="#eql-select-syntax">6.2. EQL Syntax</a></span></dt><dt><span class="sect1"><a href="#eql-select-list">6.3. Choosing Event Properties And Events: the Select Clause</a></span></dt><dd><dl><dt><span class="sect2"><a href="#eql-select-all-props">6.3.1. Choosing all event properties: select *</a></span></dt><dt><span class="sect2"><a href="#eql-select-event-props">6.3.2. Choosing specific event properties</a></span></dt><dt><span class="sect2"><a href="#eql-select-expressions">6.3.3. Expressions</a></span></dt><dt><span class="sect2"><a href="#eql-select-renaming">6.3.4. Renaming event properties</a></span></dt></dl></dd><dt><span class="sect1"><a href="#eql-from-clause">6.4. Specifying Event Streams : the From Clause</a></span></dt><dd><dl><dt><span class="sect2"><a href="#eql-from-clause-event-type">6.4.1. Specifying an event type</a></span></dt><dt><span class="sect2"><a href="#eql-from-clause-filter-criteria">6.4.2. Specifying event filter criteria</a></span></dt><dt><span class="sect2"><a href="#eql-from-clause-view-spec">6.4.3. Specifying views</a></span></dt></dl></dd><dt><span class="sect1"><a href="#eql-where-clause">6.5. Specifying Search Conditions: the Where Clause</a></span></dt><dt><span class="sect1"><a href="#eql-grouping-aggregating">6.6. Aggregates and grouping: the Group-by Clause and the Having Clause</a></span></dt><dd><dl><dt><span class="sect2"><a href="#eql-grouping-aggregate-functions">6.6.1. Using aggregate functions</a></span></dt><dt><span class="sect2"><a href="#eql-grouping-group-by">6.6.2. Organizing statement results into groups: the Group-by clause</a></span></dt><dt><span class="sect2"><a href="#eql-grouping-having">6.6.3. Selecting groups of events: the Having clause</a></span></dt><dt><span class="sect2"><a href="#eql-filter-where-grouping-having-interactions">6.6.4. How the stream filter, Where, Group By and Having clauses interact</a></span></dt></dl></dd><dt><span class="sect1"><a href="#eql-output-rate">6.7. Stabilizing and Limiting Output: the Output Clause</a></span></dt><dd><dl><dt><span class="sect2"><a href="#eql-output-options">6.7.1. Output Clause Options</a></span></dt><dt><span class="sect2"><a href="#eql-output-groupby">6.7.2. Group By, Having and Output clause interaction</a></span></dt></dl></dd><dt><span class="sect1"><a href="#eql-single-row-function-ref">6.8. Single-row function reference</a></span></dt><dt><span class="sect1"><a href="#built-in-views">6.9. Build-in views</a></span></dt><dd><dl><dt><span class="sect2"><a href="#win-views">6.9.1. Window views</a></span></dt><dd><dl><dt><span class="sect3"><a href="#view-win-length">6.9.1.1. Length window</a></span></dt><dt><span class="sect3"><a href="#view-win-time">6.9.1.2. Time window</a></span></dt><dt><span class="sect3"><a href="#view-win-ext_time">6.9.1.3. Externally-timed window</a></span></dt><dt><span class="sect3"><a href="#view-win-time-batch">6.9.1.4. Time window buffer</a></span></dt></dl></dd><dt><span class="sect2"><a href="#std-views">6.9.2. Standard view set</a></span></dt><dd><dl><dt><span class="sect3"><a href="#view-std-unique">6.9.2.1. Unique</a></span></dt><dt><span class="sect3"><a href="#view-std-groupby">6.9.2.2. Group By</a></span></dt><dt><span class="sect3"><a href="#view-std-size">6.9.2.3. Size</a></span></dt><dt><span class="sect3"><a href="#view-std-last">6.9.2.4. Last</a></span></dt></dl></dd><dt><span class="sect2"><a href="#stat-views">6.9.3. Statistics views</a></span></dt><dd><dl><dt><span class="sect3"><a href="#view-stat-uni">6.9.3.1. Univariate statistics</a></span></dt><dt><span class="sect3"><a href="#view-stat-linest">6.9.3.2. Regression</a></span></dt><dt><span class="sect3"><a href="#view-stat-correl">6.9.3.3. Correlation</a></span></dt><dt><span class="sect3"><a href="#view-stat-weightedavg">6.9.3.4. Weighted average</a></span></dt><dt><span class="sect3"><a href="#view-stat-multidim">6.9.3.5. Multi-dimensional statistics</a></span></dt></dl></dd><dt><span class="sect2"><a href="#ext-views">6.9.4. Extension View Set</a></span></dt><dd><dl><dt><span class="sect3"><a href="#view-ext-sort">6.9.4.1. Sorted Window View</a></span></dt></dl></dd></dl></dd><dt><span class="sect1"><a href="#eql-join">6.10. Joining Event Streams</a></span></dt><dt><span class="sect1"><a href="#eql-outerjoin">6.11. Outer Join</a></span></dt><dt><span class="sect1"><a href="#view-adding-views">6.12. View Plug-in</a></span></dt></dl></dd><dt><span class="chapter"><a href="#Adapters">7. Adapters</a></span></dt><dd><dl><dt><span class="sect1"><a href="#adapter-intro">7.1. Adapter</a></span></dt></dl></dd><dt><span class="chapter"><a href="#Indicators">8. Indicators</a></span></dt><dd><dl><dt><span class="sect1"><a href="#indicators-intro">8.1. Intro</a></span></dt><dt><span class="sect1"><a href="#indicators-jmx">8.2. JMX Indicator</a></span></dt></dl></dd><dt><span class="chapter"><a href="#examples">9. Examples</a></span></dt><dd><dl><dt><span class="sect1"><a href="#examples-overview">9.1. Examples Overview</a></span></dt><dt><span class="sect1"><a href="#examples-transaction-3-event-challenge">9.2. Transaction 3-Event Challenge</a></span></dt><dd><dl><dt><span class="sect2"><a href="#examples-txn3event-1">9.2.1. The Events</a></span></dt><dt><span class="sect2"><a href="#examples-txn3event-2">9.2.2. Combined event</a></span></dt><dt><span class="sect2"><a href="#examples-txn3event-3">9.2.3. Real time summary data</a></span></dt><dt><span class="sect2"><a href="#examples-txn3event-4">9.2.4. Find problems</a></span></dt><dt><span class="sect2"><a href="#examples-txn3event-5">9.2.5. Event generator</a></span></dt></dl></dd><dt><span class="sect1"><a href="#examples-stockticker">9.3. StockTicker</a></span></dt><dt><span class="sect1"><a href="#examples-matchmaker">9.4. MatchMaker</a></span></dt><dt><span class="sect1"><a href="#examples-qossla">9.5. QualityOfService</a></span></dt><dt><span class="sect1"><a href="#examples-linearroad">9.6. LinearRoad</a></span></dt><dt><span class="sect1"><a href="#examples-stocktick-rsi">9.7. StockTick RSI</a></span></dt></dl></dd><dt><span class="chapter"><a href="#references">10. References</a></span></dt><dd><dl><dt><span class="sect1"><a href="#references-listing">10.1. Reference List</a></span></dt></dl></dd></dl></div><div class="preface" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="preface"></a>Preface</h2></div></div><div></div></div><p>
			Analyzing and reacting to information in real-time oftentimes requires the development of custom applications.
			Typically these applications must obtain the data to analyze, filter data, derive information and then indicate 
			this information through some form of presentation or communication. Data may arrive with high frequency
			requiring high throughput processing. And applications may need to be flexible and react to changes in requirements 
			while the data is processed. Esper is an event stream processor that aims to enable a short development cycle from inception to production 
			for these types of applications.
        </p><p>
			Esper is a 100% Java component that can be embedded in Java applications. It allows push and pull of data via its subscription and pull API. Esper can be extended by building custom views, functions, windows etc.
		</p><div class="orderedlist"><ol type="1"><li><p>
                    Read <a href="#technology_overview_intro_cep" title="1.1.&nbsp;Introduction to CEP and event stream analysis">Section&nbsp;1.1, &#8220;Introduction to CEP and event stream analysis&#8221;</a> if you are new to CEP and ESP (complex event processing, event stream processing)
                </p></li><li><p>
                    Read <a href="#event-pattern-intro" title="5.1.&nbsp;Event Pattern Overview">Section&nbsp;5.1, &#8220;Event Pattern Overview&#8221;</a> for an overview over event patterns
                </p></li><li><p>
                    Read <a href="#eql-intro" title="6.1.&nbsp;EQL Introduction">Section&nbsp;6.1, &#8220;EQL Introduction&#8221;</a> for an introduction to event stream processing via EQL
                </p></li><li><p>
                    Then glance over the examples <a href="#examples-overview" title="9.1.&nbsp;Examples Overview">Section&nbsp;9.1, &#8220;Examples Overview&#8221;</a>
                </p></li></ol></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="technology_overview"></a>Chapter&nbsp;1.&nbsp;Technology Overview</h2></div></div><div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="technology_overview_intro_cep"></a>1.1.&nbsp;Introduction to CEP and event stream analysis</h2></div></div><div></div></div><p>
			The Esper engine has been developed to address the requirements of applications that analyze and react to events. Some typical examples of applications are:
        </p><div class="itemizedlist"><ul type="disc" compact><li><p>
					Business process management and automation (process monitoring, BAM, reporting exceptions) 
				</p></li><li><p>
					Finance (algorithmic trading, fraud detection, risk management)
				</p></li><li><p>
					Network and application monitoring (intrusion detection, SLA monitoring)
				</p></li><li><p>
					Sensor network applications (RFID reading, scheduling and control of fabrication lines, air traffic) 
				</p></li></ul></div><p>
			What these applications have in common is the requirement to process events (or messages) in real-time or near real-time. This is sometimes referred to as complex event processing (CEP) and event stream analysis. Key considerations for these types of applications are throughput, latency and the complexity of the logic required.
        </p><div class="itemizedlist"><ul type="disc" compact><li><p>
					High throughput - applications that process large volumes of messages (between 1,000 to 100k messages per second)
				</p></li><li><p>
					Low latency - applications that react in real-time to conditions that occur (from a few milliseconds to a few seconds)
				</p></li><li><p>
					Complex computations - applications that detect patterns among events (event correlation), filter events, aggregate time or length windows of events, join event streams, trigger based on absence of events etc.
				</p></li></ul></div><p>
			The Esper engine was designed to make it easier to build and extend CEP applications. 
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="cep_and_relational"></a>1.2.&nbsp;CEP and relational databases</h2></div></div><div></div></div><p>
			Relational databases and the standard query language (SQL) are designed for applications in which most data is fairly static and complex queries are less frequent. Also, most databases store all data on disks (except for in-memory databases) and are therefore optimized for disk access.
        </p><p>
			To retrieve data from a database an application must issue a query. If an application need the data 10 times per second it must fire the query 10 times per second. This does not scale well to hundreds or thousands of queries per second. 
        </p><p>
			Database triggers can be used to fire in response to database update events. However database triggers tend to be slow and often cannot easily perform complex condition checking and implement logic to react.  
        </p><p>
			In-memory databases may be better suited to CEP applications then traditional relational database as they generally have good query performance. Yet they are not optimized to provide immediate, real-time query results required for CEP and event stream analysis. 
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="cep_with_esper"></a>1.3.&nbsp;The Esper engine for CEP</h2></div></div><div></div></div><p>
			The Esper engine works a bit like a database turned upside-down. Instead of storing the data and running queries against stored data, the Esper engine allows applications to store queries and run the data through. Response from the Esper engine is real-time when conditions occur that match queries. The execution model is thus continuous rather then only when a query is submitted.
        </p><p>
			Esper provides two principal methods or mechanisms to process events: event patterns and event stream queries. 
        </p><p>
			Esper offers an event pattern language to specify expression-based event pattern matching. Underlying the pattern matching engine is a state machine implementation. This method of event processing matches expected sequences of presence or absence of events or combinations of events. It includes time-based correlation of events.
		</p><p>
			Esper also offers event stream queries that address the event stream analysis requirements of CEP applications. Event stream queries provide the windows, aggregation, joining and analysis functions for use with streams of events. These queries are following the EQL syntax. EQL has been design for similarity with the SQL query language but differs from SQL in its use of views rather then tables. Views represent the different operations needed to structure data in an event stream and to derive data from an event stream.
		</p><p>
			Esper provides these two methods as alternatives through the same API.
        </p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="architecture"></a>Chapter&nbsp;2.&nbsp;Architecture</h2></div></div><div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="architecture-overview"></a>2.1.&nbsp;Overview</h2></div></div><div></div></div><p>
            A (very) high-level view of the architecture: TODO
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="building_testing"></a>2.2.&nbsp;Building and Testing</h2></div></div><div></div></div><p>
            The Esper code base consists of about 300 source code and 270 unit test (as of release 0.7.0) or test support classes, excluding examples. After build there are over 500 unit test methods that are automatically run to verify the build. Some of the unit tests assert against performance data taken during the test. These tests are designed to run on a single 2.8 GHz Pentium 4 processor with 512MB memory.
        </p><p>
            Esper requires the following 3rd-party libraries:
        </p><div class="itemizedlist"><ul type="disc" compact><li><p>
					ANTLR is the parser generator used for parsing and parse tree walking of the pattern and EQL syntax. Credit goes to Terence Parr at http://www.antlr.org. The ANTLR license is in the lib directory. The library is required for compile-time only.
				</p></li><li><p>
					CGLIB is the code generation library for fast method calls. This open source software is under the Apache license. The Apache 2.0 license is in the lib directory.
				</p></li><li><p>
					LOG4J and Apache commons logging are logging components. This open source software is under the Apache license. The Apache 2.0 license is in the lib directory.
				</p></li><li><p>
					BeanUtils is a JavaBean manipulation library. This open source software is under the Apache license. The Apache 2.0 license is in the lib directory.
				</p></li><li><p>
					JUnit is a great unit testing framework. Its license has also been placed in the lib directory. The library is required for build-time only.
				</p></li></ul></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="configuration"></a>Chapter&nbsp;3.&nbsp;Configuration</h2></div></div><div></div></div><p>
        Esper engine configuration is entirely optional. Esper has a very small number of configuration parameters that can be used to simplify event 
        pattern and EQL statements, and to tune the engine behavior to specific requirements. The Esper engine works out-of-the-box without configuration.
    </p><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="configuration-programmatic"></a>3.1.&nbsp;Programmatic configuration</h2></div></div><div></div></div><p>
            An instance of <tt class="literal">net.esper.client.Configuration</tt> represents all configuration parameters. The <tt class="literal">Configuration</tt> is used to build an (immutable) <tt class="literal">EPServiceProvider</tt>, which provides the administrative and runtime interfaces for an Esper engine instance. 
        </p><p>
            You may obtain a <tt class="literal">Configuration</tt> instance by instantiating it directly and adding or setting values on it. The <tt class="literal">Configuration</tt> instance is then passed to <tt class="literal">EPServiceProviderManager</tt> to obtain a configured Esper engine.
        </p><pre class="programlisting">Configuration configuration = new Configuration();
configuration.addEventTypeAlias("PriceLimit", PriceLimit.class.getName());
configuration.addEventTypeAlias("StockTick", StockTick.class.getName());

EPServiceProvider epService = EPServiceProviderManager.getProvider("MyEngine", configuration);
</pre><p>
			Note that <tt class="literal">Configuration</tt> is meant only as an initialization-time object. The Esper engine represented by an <tt class="literal">EPServiceProvider</tt> is immutable and does not retain any association back to the <tt class="literal">Configuration</tt>.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="configuration-via-xml"></a>3.2.&nbsp;Configuration via XML file</h2></div></div><div></div></div><p>
			An alternative approach to configuration is to specify a configuration in an XML file. 
        </p><p>
			The default name for the XML configuration file is <tt class="literal">esper.cfg.xml</tt>. Esper reads this file from the root of the <tt class="literal">CLASSPATH</tt> as an application resource via the <tt class="literal">configure</tt> method.
        </p><pre class="programlisting">Configuration configuration = new Configuration();		
configuration.configure();
</pre><p>
			The <tt class="literal">Configuration</tt> class can read the XML configuration file from other sources as well. The <tt class="literal">configure</tt> method accepts <tt class="literal">URL, File and String</tt> filename parameters.
        </p><pre class="programlisting">Configuration configuration = new Configuration();		
configuration.configure("myengine.esper.cfg.xml");
</pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="configuration-xml"></a>3.3.&nbsp;XML Configuration file</h2></div></div><div></div></div><p>
			Here is an example configuration file. The schema for the configuration file can be found in the <tt class="literal">etc</tt> folder and is named <tt class="literal">esper-configuration-1-0</tt>.		</p><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;esper-configuration xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
           xsi:noNamespaceSchemaLocation="esper-configuration-1-0.xsd"&gt;
	&lt;event-type alias="StockTick" class="net.esper.example.stockticker.event.StockTick"/&gt;
	&lt;event-type alias="PriceLimit" class="net.esper.example.stockticker.event.PriceLimit"/&gt;
&lt;/esper-configuration&gt;		
</pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="configuration-items"></a>3.4.&nbsp;Configuration items</h2></div></div><div></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="config-event-name"></a>3.4.1.&nbsp;Event type alias to Java class mapping</h3></div></div><div></div></div><p>
				This configuration item can be set to allow event pattern statements and EQL statements to use an event type alias rather then the fully qualified Java class name. Interfaces and abstract classes are also supported as event types.
			</p><pre class="programlisting">every StockTick(symbol='IBM')"
// via configuration equivalent to
every net.esper.example.stockticker.event.StockTick(symbol='IBM')</pre></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="api"></a>Chapter&nbsp;4.&nbsp;API Reference</h2></div></div><div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="api-reference-intro"></a>4.1.&nbsp;API Overview</h2></div></div><div></div></div><p>
			Esper has 2 primary interfaces that this section outlines: The administrative interface and the runtime interface.
        </p><p>
			Use Esper's administrative interface to create event patterns and EQL statements as discussed in <a href="#event-pattern-intro" title="5.1.&nbsp;Event Pattern Overview">Section&nbsp;5.1, &#8220;Event Pattern Overview&#8221;</a> and <a href="#eql-intro" title="6.1.&nbsp;EQL Introduction">Section&nbsp;6.1, &#8220;EQL Introduction&#8221;</a>. 
        </p><p>
			Use Esper's runtime interface to send events into the engine, emit events and get statistics for an engine instance.
        </p><p>
			The JavaDoc documentation is also a great source for API information.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="api-engine-instances"></a>4.2.&nbsp;Engine Instances</h2></div></div><div></div></div><p>
			Each instance of an Esper engine is completely independent of other engine instances and has its own administrative and runtime interface.
        </p><p>
			An instance of the Esper engine is obtained via static methods on the <tt class="literal">EPServiceProviderManager</tt> class.
			The <tt class="literal">getDefaultProvider</tt> method and the <tt class="literal">getProvider(String URI)</tt> methods return an instance of the Esper engine.
			The latter can be used to obtain multiple instances of the engine for different URI values. The <tt class="literal">EPServiceProviderManager</tt>
			determines if the URI matches all prior URI values and returns the same engine instance for the same URI value. If the URI has not been seen before, a new Engine instance 
			is created.
        </p><p>
			The code snipped below gets the default instance Esper engine. Subsequent calls to get the default engine instance return the same instance.
        </p><pre class="programlisting">EPServiceProvider epService = EPServiceProviderManager.getDefaultProvider();</pre><p>
			This code snippet gets an Esper engine for URI <tt class="literal">RFIDProcessor1</tt>. Subsequent calls to get an engine with the same URI return the same instance.
        </p><pre class="programlisting">EPServiceProvider epService = EPServiceProviderManager.getProvider("RFIDProcessor1");</pre><p>
			An existing Esper engine instance can be reset via the <tt class="literal">initialize</tt> method on the <tt class="literal">EPServiceProvider</tt> instance. This stops and removes all statements in the Engine.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="api-administrative"></a>4.3.&nbsp;The Administrative Interface</h2></div></div><div></div></div><p>
			Create event patterns or EQL statements via the administrative interface <tt class="literal">EPAdministrator</tt>.
        </p><p>
			This code snippet gets an Esper engine then creates an event pattern and an EQL statement.
        </p><pre class="programlisting">EPServiceProvider epService = EPServiceProviderManager.getDefaultProvider();
EPAdministrator admin = epService.getEPAdministrator();
EPStatement 10secRecurTrigger = admin.createPattern("every timer:at(*, *, *, *, *, */10)");
EPStatement weightedAvgView = admin.createEQL(
    "select * from MarketDataBean(symbol='IBM').win:time(60).stat:weighted_avg('price', 'volume')");
</pre><p>
			The <tt class="literal">createPattern</tt> and <tt class="literal">createEQL</tt> methods return <tt class="literal">EPStatement</tt> instances. Statements are automatically started and active when created. A statement can also be stopped and started again via the <tt class="literal">stop</tt> and <tt class="literal">start</tt> methods shown in the code snippet below.
        </p><pre class="programlisting">weightedAvgView.stop();
weightedAvgView.start();
</pre><p>
			We can subscribe to updates posted by a statement via the <tt class="literal">addListener</tt> and <tt class="literal">removeListener</tt> methods the <tt class="literal">EPStatement</tt>  statement. We need to provide an implementation of the <tt class="literal">UpdateListener</tt> interface to the statement.
        </p><pre class="programlisting">UpdateListener myListener = new MyUpdateListener();	// MyUpdateListener implements UpdateListener
weightedAvgView.addListener(myListener);
</pre><p>			
			EQL statements and event patterns publish old data and new data to registered <tt class="literal">UpdateListener</tt> listeners. 
			Old data published by views constists of the events representing the prior values of derived data held by the statement.
			New data published by views is the events representing the new values of derived data held by the statement.
		</p><p>
			Subscribing to events posted by a statement is following a push model. The engine pushes data to listeners when events are received that cause data to change or patterns to match. Alternatively, statements can also serve up data in a pull model via the <tt class="literal">iterator</tt> method. This can come in handy if we are not interested in all new updates, but only want to perform a frequent poll for the latest data. For example, an event pattern that fires every 5 seconds could be used to pull data from an EQL statement. The code snippet below demonstrates some pull code.			
        </p><pre class="programlisting">Iterator&lt;EventBean&gt; eventIter = weightedAvgView.iterator();
for (EventBean event : eventIter) {
   // .. do something ..
}
</pre><p>
			This is a second example:
        </p><pre class="programlisting">double averagePrice = (Double) eqlStatement.iterator().next().get("average");</pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="api-runtime"></a>4.4.&nbsp;The Runtime Interface</h2></div></div><div></div></div><p>
			The <tt class="literal">EPRuntime</tt> interface is used to send events for processing into an Esper engine, and to emit Events from an engine instance to the outside world.
        </p><p>
			The below code snippet shows how to send events to the engine.
        </p><pre class="programlisting">EPServiceProvider epService = EPServiceProviderManager.getDefaultProvider();
EPRuntime runtime = epService.getEPRuntime();

// Send an example event containing stock market data
runtime.sendEvent(new MarketDataBean('IBM', 75.0));		
</pre><p>
			Another important method in the runtime interface is the <tt class="literal">route</tt> method. This method is designed for use by <tt class="literal">UpdateListener</tt> implementations that
			need to send events into an engine instance.
        </p><p>
			The <tt class="literal">emit</tt> and <tt class="literal">addEmittedListener</tt> methods can be used to emit events from a runtime to a registered set of one or more emitted event listeners. 
			Events are emitted on an event channel identified by a name. Listeners are implementations of the <tt class="literal">EmittedListener</tt> interface. Listeners can specify a channel to 
			listen to and thus only receive events posted to that channel. Listeners can also supply no channel name and thus receive emitted events posted on any channel. Channels are
			uniquely identified by a string channel name.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="api-event-class-reqs"></a>4.5.&nbsp;Event Class Requirements</h2></div></div><div></div></div><p>
			An event is an immutable record of a past occurence of an action or state change. An event can have a set of event properties that supply information about the event. An event also has an event class.
        </p><p>
			In Esper, events are object instances that expose event properties through JavaBean-style getter methods. Events classes or interfaces do not have to be fully compliant to the JavaBean specification; however for the Esper engine to obtain event properties, the required JavaBean getter methods must be present.
        </p><p>
			Esper supports JavaBean-style event classes that extend a superclass or implement one or more interfaces. Also, Esper event pattern and EQL statements can refer to Java interface classes and abstract classes. 
        </p><p>
			Classes that represent events should be made immutable. As events are recordings of a state change or action that occured in the past, the relevant event properties should not be changable. However this is not a hard requirement and the Esper engine accepts events that are mutable as well.
        </p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="event-properties"></a>4.5.1.&nbsp;Event Property Types</h3></div></div><div></div></div><p>
				The set of possible property types supported by a JavaBean and by Esper can be broken into below categories -- some of which are supported by the standard JavaBeans specification, and some of which are uniquely supported by Esper:
			</p><div class="itemizedlist"><ul type="disc" compact><li><p>
						<span class="emphasis"><em>Simple</em></span> properties have a single value that may be retrieved. The underlying property type might be a Java language primitive (such as int, a simple object (such as a java.lang.String), or a more complex object whose class is defined either by the Java language, by the application, or by a class library included with the application. 				
					</p></li><li><p>
						<span class="emphasis"><em>Indexed</em></span> - An indexed property stores an ordered collection of objects (all of the same type) that can be individually accessed by an integer-valued, non-negative index (or subscript). Alternatively, the entire set of values may be retrieved using an array. 
					</p></li><li><p>
						<span class="emphasis"><em>Mapped</em></span> - As an extension to standard JavaBeans APIs, Esper considers any property that accepts a String-valued key a mapped property. 
					</p></li><li><p>
						<span class="emphasis"><em>Nested</em></span> - A nested property is a property that lives within another Java object which itself is a property of an event. 
					</p></li></ul></div><p>
			Assume there is an EmployeeEvent event class as shown below. The mapped and indexed properties in this example return Java objects but could also return Java language primitive types (such as int or String). The Address object and Employee objects can themselves have properties that are nested within them, such as a streetName in the Address object or a name of the employee in the Employee object.
		</p><pre class="programlisting">public class EmployeeEvent {
	public String getFirstName();
	public Address getAddress(String type);
	public Employee getSubordinate(int index);
	public Employee[] getAllSubordinates();
}
</pre><p>
			<span class="emphasis"><em>Simple</em></span> event properties require a getter-method that returns the property value. In this example, the <tt class="literal">getFirstName</tt> getter method returns the <tt class="literal">firstName</tt> event property of type String.
		</p><p>
			<span class="emphasis"><em>Indexed</em></span> event properties require either one of the following getter-methods. A method that takes an integer-type key value and returns the property value, such as the <tt class="literal">getSubordinate</tt> method. Or a method that returns an array-type such as the <tt class="literal">getSubordinates</tt> getter method, which returns an array of Employee. In an EQL or event pattern statement, indexed properties are accessed via the <tt class="literal">property[index]</tt> syntax.
		</p><p>
			<span class="emphasis"><em>Mapped</em></span> event properties require a getter-method that takes a String-typed key value and returns the property value, such as the <tt class="literal">getAddress</tt> method. In an EQL or event pattern statement, mapped properties are accessed via the <tt class="literal">property('key')</tt> syntax.
		</p><p>
			<span class="emphasis"><em>Nested</em></span> event properties require a getter-method that returns the nesting object. The <tt class="literal">getAddress</tt> and <tt class="literal">getSubordinate</tt> methods are mapped and indexed properties that return a nesting object. In an EQL or event pattern statement, nested properties are accessed via the <tt class="literal">property.nestedProperty</tt> syntax.
		</p><p>
			All event pattern and EQL statements allow the use of indexed, mapped and nested properties (or a combination of these) anywhere where one or more event property names are expected. The below example shows different combinations of indexed, mapped and nested properties in filters of event pattern expressions.
		</p><pre class="programlisting">every EmployeeEvent(firstName='myName')
every EmployeeEvent(address('home').streetName='Park Avenue')
every EmployeeEvent(subordinate[0].name='anotherName')
every EmployeeEvent(allSubordinates[1].name='thatName')
every EmployeeEvent(subordinate[0].address('home').streetName='Water Street')
</pre><p>
			Similarly, the syntax can be used in EQL statements in all places where an event property name is expected, such as in select lists, where-clauses or join criteria.
		</p><pre class="programlisting">select firstName, address('work'), subordinate[0].name, subordinate[1].name
from EmployeeEvent
where address('work').streetName = 'Park Ave'
</pre></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="api-controlling-time"></a>4.6.&nbsp;Time-Keeping Events</h2></div></div><div></div></div><p>
			Special events are provided that can be used to control the time-keeping of an engine instance. There are two models for an engine to keep track of time.
			Internal clocking is when the engine instance relies on the <tt class="literal">java.util.Timer</tt> class for time tick events. External clocking can be used to supply time ticks to the engine. The latter is useful for testing time-based event sequences or for synchronizing the engine with an external time source.
        </p><p>
			By default, the Esper engine uses internal time ticks. This behavior can be changed by sending a timer control event to the engine as shown below.
        </p><pre class="programlisting">EPServiceProvider epService = EPServiceProviderManager.getDefaultProvider();
EPRuntime runtime = epService.getEPRuntime();
// switch to external clocking
runtime.sendEvent(new TimerControlEvent(TimerControlEvent.ClockType.CLOCK_EXTERNAL));

// send a time tick
long timeInMillis = System.currentTimeMillis();	// Or get the time somewhere else
runtime.sendEvent(new CurrentTimeEvent(timeInMillis));
</pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="api-events-received"></a>4.7.&nbsp;Events Received from the Engine</h2></div></div><div></div></div><p>
			The Esper engine posts events to registered <tt class="literal">UpdateListener</tt> instances ('push' method for receiving events). For many statements events can also be pulled from statements via the <tt class="literal">iterator</tt> method. Both pull and push supply <tt class="literal">EventBean</tt> instances representing the events generated by the engine or events supplied to the engine. Each <tt class="literal">EventBean</tt> instance represents an event, with each event being either an artificial event, composite event or an event supplied to the engine via its runtime interface.
        </p><p>
			The <tt class="literal">getEventType</tt> method supplies an event's event type information represented by an <tt class="literal">EventType</tt> instance. The <tt class="literal">EventType</tt> supplies event property names and types as well as information about the underlying object to the event.
        </p><p>
			The engine may generate artificial events that contain information derived from event streams. A typical example for artificial events is the events posted for a statement to calculate univariate statistics on an event property. The below example shows such a statement and queries the generated events for an average value.
        </p><pre class="programlisting">// Derive univariate statistics on price for the last 100 market data events
String viewExpr = "select * from MarketDataBean(symbol='IBM').win:length(100).stat:uni('price')";
EPStatement priceStatsView = epService.getEPAdministrator().createEQL(viewExpr);
priceStatsView.addListener(testListener);
</pre><pre class="programlisting">// Example listener code
public class MyUpdateListener implements UpdateListener
{
    public void update(EventBean[] newData, EventBean[] oldData)
    {
		// Interrogate events
		System.out.println("new average price=" + newData[0].get("average");
	}
}
</pre><p>
			Composite events are events that aggregate one or more other events. Composite events are typically created by the engine for statements that join two event streams, and for event patterns in which the causal events are retained and reported in a composite event. The example below shows such an event pattern.
        </p><pre class="programlisting">// Look for a pattern where AEvent follows BEvent
String pattern = "a=AEvent -&gt; b=BEvent";
EPStatement stmt = epService.getEPAdministrator().createPattern(pattern);
stmt.addListener(testListener);
</pre><pre class="programlisting">// Example listener code
public class MyUpdateListener implements UpdateListener
{
    public void update(EventBean[] newData, EventBean[] oldData)
    {
		System.out.println("a event=" + newData[0].get("a").getUnderlying());
		System.out.println("b event=" + newData[0].get("b").getUnderlying());
	}
}
</pre></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="event_patterns"></a>Chapter&nbsp;5.&nbsp;Event Pattern Reference</h2></div></div><div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="event-pattern-intro"></a>5.1.&nbsp;Event Pattern Overview</h2></div></div><div></div></div><p>
			Event patterns match when an event or multiple events occur that match the pattern's definition. Patterns can also be time-based.
         </p><p>
			Pattern expressions can consist of filter expressions combined with pattern operators. Expressions can contain further nested
			pattern expressions by including the nested expression(s) in <tt class="literal">()</tt> round brackets.
         </p><p>
			There are 5 types of operators:
         </p><div class="orderedlist"><ol type="1" compact><li><p>
					Operators that control pattern finder creation and termination: <tt class="literal">every</tt>
				</p></li><li><p>
					Logical operators: <tt class="literal">and</tt>, <tt class="literal">or</tt>, <tt class="literal">not</tt>
				</p></li><li><p>
					Temporal operators that operate on event order: <tt class="literal">-&gt;</tt> (followed-by)
				</p></li><li><p>
					Guards are where-conditions that filter out events and cause termination of the pattern finder. Examples are <tt class="literal">timer:within</tt>.
				</p></li><li><p>
					Observers observe time events as well as other events. Examples are <tt class="literal">timer:interval</tt> and <tt class="literal">timer:at</tt>.
				</p></li></ol></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="pattern-how-to-use"></a>5.2.&nbsp;How to use Patterns</h2></div></div><div></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="pattern-howto-syntax"></a>5.2.1.&nbsp;Pattern Syntax</h3></div></div><div></div></div><p>
				The <tt class="literal">createPattern</tt> method on the <tt class="literal">EPAdministrator</tt> administrative interface creates pattern statements 
				for the given pattern expression string.
			</p><p>
				This is an example pattern expression that matches on every <tt class="literal">ServiceMeasurement</tt> events in which the
				value of the <tt class="literal">latency</tt> event property is over 20 seconds, and on every<tt class="literal">ServiceMeasurement</tt> events in which the
				<tt class="literal">success</tt> property is false. Either one or the other condition must be true for this pattern to match.
			</p><pre class="programlisting">every (spike=ServiceMeasurement(latency&gt;20000) or error=ServiceMeasurement(success=false))</pre><p>
				The Java code to create this trigger is below.
			</p><pre class="programlisting">EPAdministrator admin = EPServiceProviderManager.getDefaultProvider().getEPAdministrator();

String eventName = ServiceMeasurement.class.getName();

EPStatement myTrigger = admin.createPattern(
  "every (spike=" + eventName + "(latency&gt;20000) or error=" + eventName + "(success=false))");
</pre><p>
				The pattern expression starts with an <tt class="literal">every</tt> operator to indicate that the pattern should fire for every matching events and not just the first
				matching event. Within the <tt class="literal">every</tt> operator in round brackets is a nested pattern expression using the <tt class="literal">or</tt> operator. 
				The left hand of the <tt class="literal">or</tt> operator is a filter expression that filters for events with a high latency value. The right hand of the operator 
				contains a filter expression that filters for events with error status. Filter expressions are explained in <a href="#pattern-filter" title="5.3.&nbsp;Filter Expressions">Section&nbsp;5.3, &#8220;Filter Expressions&#8221;</a>.
			</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="patterns-howto-subscribe"></a>5.2.2.&nbsp;Subscribing to Pattern Events</h3></div></div><div></div></div><p>			
				When a pattern fires it publishes one or more events to any listeners to the pattern statement. 
				The listener interface is the <tt class="literal">net.esper.client.UpdateListener</tt> interface.
			</p><p>            
				The example below shows an anonymous implementation of the <tt class="literal">net.esper.client.UpdateListener</tt> interface.
				We add the anonymous listener implementation to the <tt class="literal">myPattern</tt> statement created earlier. 
				The listener code simply extracts the underlying event class.
			</p><pre class="programlisting">myPattern.addListener(new UpdateListener()
{
	public void update(EventBean[] newEvents, EventBean[] oldEvents)
	{
		ServiceMeasurement spike = (ServiceMeasurement) newEvents[0].get("spike");
		ServiceMeasurement error = (ServiceMeasurement) newEvents[0].get("error");
		... // either spike or error can be null, depending on which occured
		... // add more logic here
	}
});
</pre><p>            
				Listeners receive an array of <tt class="literal">EventBean</tt> instances in the <tt class="literal">newEvents</tt> parameter.
				There is one <tt class="literal">EventBean</tt> instance passed to the listener for each combination of events that matches
				the pattern expression. At least one <tt class="literal">EventBean</tt> instance is always passed to the listener.
			</p><p>
				The properties of each <tt class="literal">EventBean</tt> instance contain the underlying events that caused the
				pattern to fire, if events have been named in the filter expression via the <tt class="literal">name=eventType</tt> syntax.
				The property name is thus the name supplied in the pattern expression, while the property type is the type of the underlying class, 
				in this example <tt class="literal">ServiceMeasurement</tt>.
			</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="pattern-howto-pull-data"></a>5.2.3.&nbsp;Pulling Data from Patterns</h3></div></div><div></div></div><p>
				Data can also be pulled from pattern statements via the <tt class="literal">iterator()</tt> method. 
				If the pattern had fired at least once, then the iterator returns the last event for which it fired.
				The <tt class="literal">hasNext()</tt> method can be used to determine if the pattern had fired.				 				
			</p><pre class="programlisting">if (myPattern.iterator().hasNext())
{
	ServiceMeasurement event = (ServiceMeasurement) view.iterator().next().get("alert");
    ... // some more code here to process the event
}
else
{
    ... // no matching events at this time
}</pre></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="pattern-filter"></a>5.3.&nbsp;Filter Expressions</h2></div></div><div></div></div><p>
            This chapter outines how to filter events based on their properties.
        </p><p>
            The simplest form of filter is a filter for events of a given type without any conditions on the event property values. This filter matches any event of that type regardless of the event's properties. The example below is such a filter. Note that this event pattern would stop firing as soon as the first RfidEvent is encountered.
         </p><pre class="programlisting">com.mypackage.myevents.RfidEvent</pre><p>
			 To make the event pattern fire for every RfidEvent and not just the first event, use the <tt class="literal">every</tt> keyword.
		 </p><pre class="programlisting">every com.mypackage.myevents.RfidEvent</pre><p>
			 The example above specifies the fully-qualified Java class name as the event type. Via configuration, the event pattern above can be simplified by using the alias
			 that has been defined for the event type. Interfaces and abstract classes are also supported as event types.
		 </p><pre class="programlisting">every RfidEvent</pre><p>
			 Interfaces and superclasses are also supported as event types. In the below example <tt class="literal">IRfidReadable</tt> is an interface class.
		 </p><pre class="programlisting">every org.myorg.rfid.IRfidReadable</pre><p>
            The filtering criteria to filter for events with certain event property values are placed within parenthesis after the event type name.
         </p><pre class="programlisting">mypackage.RfidEvent(category="Perishable")</pre><p>
            The supported filter operators are
        </p><div class="itemizedlist"><ul type="disc" compact><li><p>
                    equals <tt class="literal">=</tt>
                </p></li><li><p>
                    comparison operators <tt class="literal">&lt; , &gt; , &gt;=, &lt;=</tt>
                </p></li><li><p>
                    ranges use the keyword <tt class="literal">in </tt> and round <tt class="literal">(...)</tt> or square brackets <tt class="literal">[]</tt>
                </p></li></ul></div><p>
			Ranges come in the following 4 varieties. The use of round <tt class="literal">()</tt> 
			or square <tt class="literal">[]</tt> bracket dictates whether an endpoint is included or excluded.
         </p><div class="itemizedlist"><ul type="disc" compact><li><p>
                    Open ranges that contain neither endpoint <tt class="literal">(low:high)</tt>
                </p></li><li><p>
                    Closed ranges that contain both endpoints <tt class="literal">[low:high]</tt>
                </p></li><li><p>
                    Half-open ranges that contain the low endpoint but not the high endpoint <tt class="literal">[low:high)</tt>
                </p></li><li><p>
                    Half-closed ranges that contain the high endpoint but not the low endpoint <tt class="literal">(low:high]</tt>
                </p></li></ul></div><p>
            Filter criteria are listed in a comma-separated format. In the example below we look for <tt class="literal">RfidEvent</tt> events with
            a <tt class="literal">grade</tt> property between 1 and 2 (endpoints included), a <tt class="literal">price</tt> less then 1, and a category of "Perishable".
         </p><pre class="programlisting">mypackage.RfidEvent(category="Perishable", price&lt;1.00, grade in [1:2])</pre><p>
            Filter criteria can also refer to events machting prior named events in the same expression. Below pattern is an example in which the pattern
            matches once for every RfidEvent that is preceded by an RfidEvent with the same item id.
         </p><pre class="programlisting">every A=mypackage.RfidEvent -&gt; B=mypackage.RfidEvent(itemId=A.itemId)</pre><p>
            The syntax shown above allows filter criteria to reference prior results by specifying the event name and event property. This syntax can be used with all filter operators.
         </p><p>
            Some limitations of filters are:
        </p><div class="itemizedlist"><ul type="disc" compact><li><p>
                    Range and comparison operators require the event property to be of a numeric type. 
                </p></li><li><p>
                    Null values in filter criteria are currently not allowed.
                </p></li><li><p>
                    Filter criteria can list the same event property only once. 
                </p></li><li><p>
                    Events that have null values for event properties listed in the filter criteria do not match the criteria.
                </p></li></ul></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="pattern-operators"></a>5.4.&nbsp;Pattern Operators</h2></div></div><div></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="pattern-logical-every"></a>5.4.1.&nbsp;Every</h3></div></div><div></div></div><p>				
				The <tt class="literal">every</tt> operator indicates that the pattern expression should restart when the pattern matches.
				Without the <tt class="literal">every</tt> operator the pattern expressions matcher stops when the pattern matches once.
            </p><p>
				Thus the <tt class="literal">every</tt> operator works like a factory for the pattern expression contained within. When the pattern expression within it 
				fires and thus quits checking for events, the <tt class="literal">every</tt> causes the start of a new pattern matcher listening for more occurances of the same
				event or set of events.
            </p><p>
				Every time a pattern expression within an <tt class="literal">every</tt> operator turns true a new active pattern matcher is started looking 
				for more event(s) or timing conditions that match the pattern expression. If the <tt class="literal">every</tt> operator is not specified for an expression, 
				the expression stops after the first match was found.
            </p><p>
				This pattern fires when encountering event A and then stops looking.
            </p><pre class="programlisting">A</pre><p>
				This pattern keeps firing when encountering event A, and doesn't stop looking.
            </p><pre class="programlisting">every A</pre><p>
				Let's consider an example event sequence as follows.
            </p><p>
				A<sub>1</sub>   
				B<sub>1</sub>   
				C<sub>1</sub>   
				B<sub>2</sub>   
				A<sub>2</sub>   
				D<sub>1</sub>   
				A<sub>3</sub>   
				B<sub>3</sub>   
				E<sub>1</sub>   
				A<sub>4</sub>   
				F<sub>1</sub>   
				B<sub>4</sub>   
            </p><div class="table"><a name="pattern-every-samples"></a><p class="title"><b>Table&nbsp;5.1.&nbsp;'Every' operator examples</b></p><table summary="'Every' operator examples" border="1"><colgroup><col><col></colgroup><thead><tr><th>Example</th><th>Description</th></tr></thead><tbody><tr><td><pre class="programlisting">every ( A -&gt; B )</pre></td><td><p>
									Detect event A followed by event B. 
									At the time when B occurs the pattern matches, then the pattern matcher restarts and looks for event A again.
								</p><div class="orderedlist"><ol type="1" compact><li><p>
											Matches on B<sub>1</sub> for combination {A<sub>1</sub>, B<sub>1</sub>}
										</p></li><li><p>
											Matches on B<sub>3</sub> for combination {A<sub>2</sub>, B<sub>3</sub>}
										</p></li><li><p>
											Matches on B<sub>4</sub> for combination {A<sub>4</sub>, B<sub>4</sub>}
										</p></li></ol></div></td></tr><tr><td><pre class="programlisting">every A -&gt; B</pre></td><td><p>
									The pattern fires for every event A followed by an event B.
								</p><div class="orderedlist"><ol type="1" compact><li><p>
											Matches on B<sub>1</sub> for combination {A<sub>1</sub>, B<sub>1</sub>}
										</p></li><li><p>
											Matches on B<sub>3</sub> for combination {A<sub>2</sub>, B<sub>3</sub>}
											and {A<sub>3</sub>, B<sub>3</sub>}
										</p></li><li><p>
											Matches on B<sub>4</sub> for combination {A<sub>4</sub>, B<sub>4</sub>}
										</p></li></ol></div></td></tr><tr><td><pre class="programlisting">A -&gt; every B</pre></td><td><p>
									The pattern fires for an event A followed by every event B.
								</p><div class="orderedlist"><ol type="1" compact><li><p>
											Matches on B<sub>1</sub> for combination {A<sub>1</sub>, B<sub>1</sub>}.
										</p></li><li><p>
											Matches on B<sub>2</sub> for combination {A<sub>1</sub>, B<sub>2</sub>}.
										</p></li><li><p>
											Matches on B<sub>3</sub> for combination {A<sub>1</sub>, B<sub>3</sub>}
										</p></li><li><p>
											Matches on B<sub>4</sub> for combination {A<sub>1</sub>, B<sub>4</sub>}
										</p></li></ol></div></td></tr><tr><td><pre class="programlisting">every A -&gt; every B</pre></td><td><p>
									The pattern fires for every event A followed by every event B.
								</p><div class="orderedlist"><ol type="1" compact><li><p>
											Matches on B<sub>1</sub> for combination {A<sub>1</sub>, B<sub>1</sub>}.
										</p></li><li><p>
											Matches on B<sub>2</sub> for combination {A<sub>1</sub>, B<sub>2</sub>}.
										</p></li><li><p>
											Matches on B<sub>3</sub> for combination {A<sub>1</sub>, B<sub>3</sub>}
											and {A<sub>2</sub>, B<sub>3</sub>} and {A<sub>3</sub>, B<sub>3</sub>}
										</p></li><li><p>
											Matches on B<sub>4</sub> for combination {A<sub>1</sub>, B<sub>4</sub>}
											and {A<sub>2</sub>, B<sub>4</sub>} and {A<sub>3</sub>, B<sub>4</sub>}
											and {A<sub>4</sub>, B<sub>4</sub>}
										</p></li></ol></div></td></tr></tbody></table></div><p>
				The examples show that it is possible that a pattern fires for multiple combinations of events that match a pattern expression.
				Each combination is posted as an <tt class="literal">EventBean</tt> instance to the <tt class="literal">update</tt> method in the <tt class="literal">UpdateListener</tt> implementation.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="pattern-logical-and"></a>5.4.2.&nbsp;And</h3></div></div><div></div></div><p>
				Similar to the Java &amp;&amp; operator the <tt class="literal">and</tt> operator requires both nested pattern expressions to turn 
				true before the whole expression turns true (a join pattern).
            </p><p>
				Pattern matches when both event A and event B are found.
            </p><pre class="programlisting">A and B</pre><p>
				Pattern matches on any sequence A followed by B and C followed by D, or C followed by D and A followed by B
            </p><pre class="programlisting">(A -&gt; B) and (C -&gt; D)</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="pattern-logical-or"></a>5.4.3.&nbsp;Or</h3></div></div><div></div></div><p>
				Similar to the Java &#8220;||&#8221; operator the <tt class="literal">or</tt> operator requires either one of the expressions 
				to turn true before the whole expression turns true.
            </p><p>
			   Look for either event A or event B. As always, A and B can itself be nested expressions as well.
            </p><pre class="programlisting">A or B</pre><p>
				Detect all stock ticks that are either above or below a threshold.
            </p><pre class="programlisting">every (StockTick(symbol='IBM', price &lt; 100) or StockTick(symbol='IBM', price &gt; 105)</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="pattern-logical-not"></a>5.4.4.&nbsp;Not</h3></div></div><div></div></div><p>
				The <tt class="literal">not</tt> operator negates the truth value of an expression. Pattern expressions prefixed with <tt class="literal">not</tt> are automatically 
				defaulted to true.
            </p><p>
				This pattern matches only when an event A is encountered followed by event B but only if no event C was encountered before event B.          
            </p><pre class="programlisting">( A -&gt; B ) and not C</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="pattern-temporal-followed-by"></a>5.4.5.&nbsp;Followed-by</h3></div></div><div></div></div><p>
				The followed by <tt class="literal">-&gt;</tt> operator specifies that first the left hand expression must turn true and only 
				then is the right hand expression evaluated for matching events.
            </p><p>
				Look for event A and if encountered, look for event B. As always, A and B can itself be nested event pattern expressions.
            </p><pre class="programlisting">A -&gt; B</pre><p>
				This is a pattern that fires when 2 status events indicating an error occur one after the other.
            </p><pre class="programlisting">StatusEvent(status='ERROR') -&gt; StatusEvent(status='ERROR')</pre></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="pattern-guards"></a>5.5.&nbsp;Guards</h2></div></div><div></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="pattern-timer-within"></a>5.5.1.&nbsp;timer:within</h3></div></div><div></div></div><p>
				The <tt class="literal">timer:within</tt> guard acts like a stopwatch. 
				If the associated pattern expression does not turn true within the specified time period it is stopped and permanently false.
            </p><p>
				This pattern fires for all A events that arrive within 5 seconds.
            </p><pre class="programlisting">every A where timer:within (5000)</pre><p>
				This pattern matches for any A or B events in the next 5 seconds.
            </p><pre class="programlisting">( A or B ) where timer:within (5000)</pre><p>
				This pattern matches for any 2 errors that happen 10 seconds within each other.
            </p><pre class="programlisting">every (StatusEvent(status='ERROR') -&gt; StatusEvent(status='ERROR') where timer:within (10000))</pre></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="pattern-observers"></a>5.6.&nbsp;Pattern Observers</h2></div></div><div></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="pattern-timer-interval"></a>5.6.1.&nbsp;timer:interval</h3></div></div><div></div></div><p>
				The <tt class="literal">timer:interval</tt> observer takes a wait time in milliseconds and waits for the defined time before the 
				truth value of the observer turns true.
            </p><p>
				After event A arrived wait 10 seconds then indicate that the pattern matches.
            </p><pre class="programlisting">A -&gt; timer:interval(10000) </pre><p>
				The pattern below fires every 20 seconds.
            </p><pre class="programlisting">every timer:interval(20000)</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="pattern-timer-at"></a>5.6.2.&nbsp;timer:at</h3></div></div><div></div></div><p>
				The <tt class="literal">timer:at</tt> observer is similar in function to the Unix &#8220;crontab&#8221; command. At a specified time the 
				expression turns true. The <tt class="literal">at</tt> operator can also be made to pattern match at regular intervals by using an <tt class="literal">every</tt> operator 
				in front of the <tt class="literal">timer:at</tt> operator. 
            </p><p>
				The syntax is: <tt class="literal">timer:at (minutes, hours, days of month, months, days of week [, seconds]).</tt>
            </p><p>
				The value for seconds is optional. Each element allows wildcard <tt class="literal">*</tt> values. Ranges can be specified 
				by means of lower bounds then a colon &#8216;:&#8217; then the upper bound. The division operator <tt class="literal">*/x</tt> can be used to 
				specify that every x<sub>th</sub> value is valid. Combinations of these operators can be used by placing these into square brackets([]).
            </p><p>
				This expression pattern matches every 5 minutes past the hour.
            </p><pre class="programlisting">every timer:at(5, *, *, *, *)</pre><p>
				The below at operator pattern matches every 15 minutes from 8am to 5pm on even numbered days of the month as well as on the 
				first day of the month.
            </p><pre class="programlisting">timer:at (*/15, 8:17, [*/2, 1], *, *)</pre></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="EQL"></a>Chapter&nbsp;6.&nbsp;EQL Reference</h2></div></div><div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="eql-intro"></a>6.1.&nbsp;EQL Introduction</h2></div></div><div></div></div><p>
			EQL statements are used to derive and aggregate information from one or more streams of events, and to join event streams. This section outlines EQL syntax. It also outlines the built-in views, which are the building blocks for deriving and aggregating information from event streams. 
        </p><p>
			EQL is similar to SQL in its use of the <tt class="literal">select</tt> clause and the <tt class="literal">where</tt> clause. Where EQL differs most from SQL is in the use of tables. EQL replaces tables with the concept of event streams.
        </p><p>
			EQL statements contain definitions of one or more views. Similar to tables in an SQL statement, views define the data available for querying and filtering. 
			Some views represent windows over a stream of events. Other views derive statistics from event properties, group events or handle unique event property values.
            Views can be staggered onto each other to build a chain of views. The Esper engine makes sure that views are reused among EQL statements for efficiency.
        </p><p>
			The built-in set of views is:
         </p><div class="orderedlist"><ol type="1" compact><li><p>
					Views that represent moving event windows: <tt class="literal">win:length</tt>, <tt class="literal">win:time</tt>, <tt class="literal">win:time_batch</tt>, <tt class="literal">win:ext_time</tt>, <tt class="literal">ext:sort_window</tt>
				</p></li><li><p>
					Views for aggregation: <tt class="literal">std:unique</tt>, <tt class="literal">std:groupby</tt>, <tt class="literal">std:lastevent</tt>
				</p></li><li><p>
					Views that derive statistics: <tt class="literal">std:size</tt>, <tt class="literal">stat:uni</tt>, <tt class="literal">stat:linest</tt>, <tt class="literal">stat:correl</tt>, <tt class="literal">stat:weighted_avg</tt>, 
					<tt class="literal">stat:multidim_stat</tt>
				</p></li></ol></div><p>
			Esper can be extended by plugging-in custom developed views.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="eql-select-syntax"></a>6.2.&nbsp;EQL Syntax</h2></div></div><div></div></div><p>
			EQL queries are created and stored in the engine, and publish results as events are received by the engine or timer events occur that match the criteria specified in the query. Events can also be pulled from running EQL queries.
		</p><p>
			The select clause in an EQL query specifies the event properties or events to retrieve. The <tt class="literal">from</tt> clause in an EQL query specifies the event stream definitions and stream names to use. The <tt class="literal">where</tt> clause in an EQL query specifies search conditions that specify which event or event combination to search for. For example, the following statement returns the average price for IBM stock ticks in the last 30 seconds if the average hit 75 or more.
		</p><pre class="programlisting">select average from StockTick(symbol='IBM').win:time(30).stat:uni('price') where average &gt;= 75;
</pre><p>
			EQL queries follow the below syntax. EQL queries can be simple queries or more complex queries. A simple select contains only a select clause and a single stream definition. Complex EQL queries can be build that feature a more elaborate select list utilizing expressions, may join multiple streams or may contain a where clause that with search conditions.
		</p><pre class="synopsis">select <span class="emphasis"><em>select_list</em></span>
from <span class="emphasis"><em>stream_def</em></span> [as name] [, <span class="emphasis"><em>stream_def</em></span> [as name]] [,...]
[where <span class="emphasis"><em>search_conditions</em></span>]
[group by <span class="emphasis"><em>grouping_expression_list</em></span>]
[having <span class="emphasis"><em>grouping_search_conditions</em></span>]
[output <span class="emphasis"><em>output_specification</em></span>]
</pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="eql-select-list"></a>6.3.&nbsp;Choosing Event Properties And Events: the <span class="emphasis"><em>Select</em></span> Clause</h2></div></div><div></div></div><p>
			The select clause is required in all EQL statements. The select clause can be used to select all properties via the wildcard <tt class="literal">*</tt>, or to specify a list of event properties and expressions. The select clause defines the event type (event property names and types) of the resulting events published by the statement, or pulled from the statement.
		</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="eql-select-all-props"></a>6.3.1.&nbsp;Choosing all event properties: select *</h3></div></div><div></div></div><p>
				The syntax for selecting all event properties in a stream is:
			</p><pre class="synopsis">select * from <span class="emphasis"><em>stream_def</em></span></pre><p>
				The following statement selects all univariate statistics properties for the last 30 seconds of IBM stock ticks for price.
			</p><pre class="programlisting">select * from StockTick(symbol='IBM').win:time(30).stat:uni('price')
</pre><p>
				In a join statement, using the <tt class="literal">select *</tt> syntax selects event properties that contain the events representing the joined streams themselves.
			</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="eql-select-event-props"></a>6.3.2.&nbsp;Choosing specific event properties</h3></div></div><div></div></div><p>
				To chose the particular event properties to return:
			</p><pre class="synopsis">select <span class="emphasis"><em>event_property</em></span> [, <span class="emphasis"><em>event_property</em></span>] [, ...] from <span class="emphasis"><em>stream_def</em></span></pre><p>
				The following statement selects the count and standard deviation properties for the last 100 events of IBM stock ticks for volume.
			</p><pre class="programlisting">select count, stdev from StockTick(symbol='IBM').win:length(100).stat:uni('volume')
</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="eql-select-expressions"></a>6.3.3.&nbsp;Expressions</h3></div></div><div></div></div><p>
				The select clause can contain one or more expressions.
			</p><pre class="synopsis">select <span class="emphasis"><em>expression</em></span> [, <span class="emphasis"><em>expression</em></span>] [, ...] from <span class="emphasis"><em>stream_def</em></span></pre><p>
				The following statement selects the volume multiplied by price for a time batch of the last 30 seconds of stock tick events. 
			</p><pre class="programlisting">select volume * price from StockTick.win:time_batch(30)
</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="eql-select-renaming"></a>6.3.4.&nbsp;Renaming event properties</h3></div></div><div></div></div><p>
				Event properties and expressions can be renamed using below syntax.
			</p><pre class="synopsis">select [event property | expression] as <span class="emphasis"><em>identifier</em></span> [, ...]</pre><p>
				The following statement selects volume multiplied by price and specifies the name <span class="emphasis"><em>volPrice</em></span> for the event property.
			</p><pre class="programlisting">select volume * price as volPrice from StockTick.win:length(100)
</pre></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="eql-from-clause"></a>6.4.&nbsp;Specifying Event Streams : the <span class="emphasis"><em>From</em></span> Clause</h2></div></div><div></div></div><p>
			The <tt class="literal">from</tt> clause is required in all EQL statements. It specifies one or more event streams. Each event stream can optionally be given a name by means of the <tt class="literal">as</tt> syntax.
		</p><pre class="synopsis">from <span class="emphasis"><em>stream_def</em></span> [as <span class="emphasis"><em>name</em></span>] [, <span class="emphasis"><em>stream_def</em></span> [as <span class="emphasis"><em>name</em></span>]] [, ...]</pre><p>
			The event stream definition <span class="emphasis"><em>stream_def</em></span> as shown in the syntax above consists of an event type, an optional filter property list and an optional list of views that derive data from a stream must be supplied. The syntax for an event stream definition is as below:
		</p><pre class="synopsis"><span class="emphasis"><em>event_type</em></span> ( [<span class="emphasis"><em>filter_criteria</em></span>] ) [.<span class="emphasis"><em>view_spec</em></span>] [.<span class="emphasis"><em>view_spec</em></span>] [...]</pre><p>
			The following EQL statement selects all event properties for the last 100 events of IBM stock ticks for volume. In the example, the event type is the fully qualified Java class name <tt class="literal">org.esper.example.StockTick</tt>. The expression filters for events where the property <tt class="literal">symbol</tt> has a value of "IBM". The optional view specifications for deriving data from the StockTick events are a length window and a view for computing statistics on volume. The name for the event stream is "volumeStats".
		</p><pre class="programlisting">select * from org.esper.example.StockTick(symbol='IBM').win:length(100).stat:uni('volume') as volumeStats</pre><p>
			Instead of the fully-qualified Java class name any other event name can be mapped via Configuration to a Java class, making the resulting statement more readable.
		</p><pre class="programlisting">select * from StockTick(symbol='IBM').win:length(100).stat:uni('volume') as volumeStats</pre><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="eql-from-clause-event-type"></a>6.4.1.&nbsp;Specifying an event type</h3></div></div><div></div></div><p>
				In the example above the event type was <tt class="literal">org.esper.example.StockTick</tt>. The event type is simply the fully qualified Java class name. Interfaces and abstract classes are also supported. Alternatively, via configuration an alias for an event type can be defined and used instead of the fully qualified class name. The below example shows one way to obtain the fully qualified class name of a given Java class <tt class="literal">StockTick</tt>.
			</p><pre class="programlisting">String eventName = StockTick.class.getName();
String stmt = "from " + eventName + ".win:length(100)"
</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="eql-from-clause-filter-criteria"></a>6.4.2.&nbsp;Specifying event filter criteria</h3></div></div><div></div></div><p>
				Filter criteria follow the same syntax as outlined in the event pattern section on filters; see <a href="#pattern-filter" title="5.3.&nbsp;Filter Expressions">Section&nbsp;5.3, &#8220;Filter Expressions&#8221;</a>. Filter criteria operators are: <tt class="literal">=, &lt; , &gt; , &gt;=, &lt;=</tt>. Ranges use the <tt class="literal">in </tt> keyword and round <tt class="literal">(...)</tt> or square brackets <tt class="literal">[]</tt>.
			</p><p>
				Esper filters out events in an event stream as defined by filter criteria before it sends events to subsequent views. Thus, compared to search conditions in a where-clause, filter criteria remove unneeded events early.
			</p><p>
				The below example is a filter criteria list that removes events based on category, price and grade.
			</p><pre class="programlisting">from mypackage.RfidEvent(category="Perishable", price&lt;1.00, grade in [1, 2])</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="eql-from-clause-view-spec"></a>6.4.3.&nbsp;Specifying views</h3></div></div><div></div></div><p>
				Views are used to derive or aggregate data. Views can be staggered onto each other. The section below outlines the views available and plug-in of custom views.
			</p><p>
				Views can optionally take one or parameters. These parameters can consist of primitive constants such as String, boolean or numeric types. String arrays are also supported as a view parameter type.
			</p><p>
				Views can optionally take one or parameters. These parameters can consist of primitive constants such as String, boolean or numeric types. String arrays are also supported as a view parameter type.
			</p><p>
				The below example uses the car location event. It specifies an empty list of filter criteria by adding a empty round brackets <tt class="literal">()</tt> after the event type. The first view <tt class="literal">"std:groupby('carId')"</tt> groups car location events by car id. The second view <tt class="literal">"win:length(4)"</tt> keeps a length window of the 4 last events, with one length window for each car id. The next view <tt class="literal">"std:groupby({'expressway', 'direction', 'segment'})"</tt> groups each event by it's expressway, direction and segment property values. Again, the grouping is done for each car id considering the last 4 events only. The last view <tt class="literal">"std:size()"</tt> is used to report the number of events. Thus the below example reports the number of events per car id and per expressway, direction and segment considering the last 4 events for each car id only. The <tt class="literal">"as accSegment"</tt> syntax assigns the name accSegment to the resulting event stream.
			</p><pre class="programlisting">String carLocEvent = CarLocEvent.class.getName();
String joinStatement = "select * from " +
	carLocEvent + ".std:groupby('carId').win:length(4).std:groupby({'expressway', 'direction', 'segment'}).std:size() as accSeg," +
	carLocEvent + ".win:time(30).std:unique('carId') as curCarSeg" +
		" where accSeg.size &gt;= 4" +
		"   and accSeg.expressway = curCarSeg.expressway" +
		"   and accSeg.direction = curCarSeg.direction" +
		"   and (" +
				"(accSeg.direction=0 " +
				" and curCarSeg.segment &lt; accSeg.segment" +
				" and curCarSeg.segment &gt; accSeg.segment - 5)" +
			" or " +
				"(accSeg.direction=1 " +
				" and curCarSeg.segment &gt; accSeg.segment" +
				" and curCarSeg.segment &lt; accSeg.segment + 5)" +
			")";
</pre></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="eql-where-clause"></a>6.5.&nbsp;Specifying Search Conditions: the <span class="emphasis"><em>Where</em></span> Clause</h2></div></div><div></div></div><p>
			The where clause is an optional clause in EQL statements. Via the where clause event streams can be joined and events can be filtered. 
		</p><p>
			Comparison operators <tt class="literal">=, &lt; , &gt; , &gt;=, &lt;=, !=, &lt;&gt;, is null, is not null</tt> and logical combinations via <tt class="literal">and</tt> and <tt class="literal">or</tt> are supported in the where clause. The where clause can also introduce join conditions as outlined in <a href="#eql-join" title="6.10.&nbsp;Joining Event Streams">Section&nbsp;6.10, &#8220;Joining Event Streams&#8221;</a>. Where-clauses can also contain expressions. Some examples are listed below.
		</p><pre class="programlisting">...where fraud.severity = 5 and amount &gt; 500
...where (orderItem.orderId is null) or (orderItem.class != 10)		 
...where (orderItem.orderId = null) or (orderItem.class &lt;&gt; 10)		 
...where itemCount / packageCount &gt; 10		 </pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="eql-grouping-aggregating"></a>6.6.&nbsp;Aggregates and grouping: the <span class="emphasis"><em>Group-by</em></span> Clause and the <span class="emphasis"><em>Having</em></span> Clause</h2></div></div><div></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="eql-grouping-aggregate-functions"></a>6.6.1.&nbsp;Using aggregate functions</h3></div></div><div></div></div><p>
					The aggregate functions are <tt class="literal">sum, avg, count, max, min, median, stddev, avedev</tt>. You can use aggregate functions to
					calculate and summarize data from event properties.
					For example, to find out the total price for all stock tick events in the last 30 seconds, type:
				</p><pre class="programlisting">select sum(price) from StockTickEvent.win:time(30)</pre><p>
					Here is the syntax for aggregate functions: 
				</p><pre class="synopsis"><span class="emphasis"><em>aggregate_function</em></span>( [all | distinct] <span class="emphasis"><em>expression</em></span>)</pre><p>
					You can apply aggregate functions to all events in an event stream window or other view, or to one or more groups of events. From each set of events to which 
					an aggregate function is applied, Esper generates a single value. 
				</p><p>
					<tt class="literal">Expression</tt> is usually an event property name. However it can also be a constant, function, or any combination of event property names, constants, 
					and functions connected by arithmetic operators.
				</p><p>
					For example, to find out the average price for all stock tick events in the last 30 seconds if the price was doubled:
				</p><pre class="programlisting">select avg(price * 2) from StockTickEvent.win:time(30)</pre><p>
					You can use the optional keyword <tt class="literal">distinct</tt> with all aggregate functions to eliminate duplicate values before the aggregate function is applied. The optional 
					keyword <tt class="literal">all</tt> which performs the operation on all events is the default. 
				</p><p>
					The syntax of the aggregation functions and the results they produce are shown in below table.
				</p><div class="table"><a name="eql-grouping-aggregate-func"></a><p class="title"><b>Table&nbsp;6.1.&nbsp;Syntax and results of aggregate functions</b></p><table summary="Syntax and results of aggregate functions" border="1"><colgroup><col><col></colgroup><thead><tr><th>Aggregate Function</th><th>Result</th></tr></thead><tbody><tr><td>sum([all|distinct] <span class="emphasis"><em>expression</em></span>)</td><td><p>
										Totals the (distinct) values in the expression, returning a value of <tt class="literal">long, double, float or integer</tt> type depending on the expression
									</p></td></tr><tr><td>avg([all|distinct] <span class="emphasis"><em>expression</em></span>)</td><td><p>
										Average of the (distinct) values in the expression, returning a value of <tt class="literal">double</tt> type
									</p></td></tr><tr><td>count([all|distinct] <span class="emphasis"><em>expression</em></span>)</td><td><p>
										Number of the (distinct) non-null values in the expression, returning a value of <tt class="literal">long</tt> type
									</p></td></tr><tr><td>count(*)</td><td><p>
										Number of events, returning a value of <tt class="literal">long</tt> type
									</p></td></tr><tr><td>max([all|distinct] <span class="emphasis"><em>expression</em></span>)</td><td><p>
										Highest (distinct) value in the expression, returning a value of the same type as the expression itself returns
									</p></td></tr><tr><td>min([all|distinct] <span class="emphasis"><em>expression</em></span>)</td><td><p>
										Lowest (distinct) value in the expression, returning a value of the same type as the expression itself returns
									</p></td></tr><tr><td>median([all|distinct] <span class="emphasis"><em>expression</em></span>)</td><td><p>
										Median (distinct) value in the expression, returning a value of <tt class="literal">double</tt> type
									</p></td></tr><tr><td>stddev([all|distinct] <span class="emphasis"><em>expression</em></span>)</td><td><p>
										Standard deviation of the (distinct) values in the expression, returning a value of <tt class="literal">double</tt> type
									</p></td></tr><tr><td>avedev([all|distinct] <span class="emphasis"><em>expression</em></span>)</td><td><p>
										Mean deviation of the (distinct) values in the expression, returning a value of <tt class="literal">double</tt> type
									</p></td></tr></tbody></table></div><p>
					You can use aggregation functions in a <tt class="literal">select</tt> clause and in a <tt class="literal">having</tt> clause. You cannot use aggregate functions in a <tt class="literal">where</tt> clause, but you can use the where clause to restrict the events to which the aggregate is applied. The next query computes the average and sum of the price of stock tick events for the symbol IBM only, for the last 10 stock tick events regardless of their symbol.
				</p><pre class="programlisting">select 'IBM stats' as title, avg(price) as avgPrice, sum(price) as sumPrice
from StockTickEvent.win:length(10)
where symbol='IBM'</pre><p>
					In the above example the length window of 10 elements is not affected by the where-clause, i.e. all events enter and leave the length window regardless of their symbol. If we only care about the last 10 IBM events, we need to add filter criteria as below.
				</p><pre class="programlisting">select 'IBM stats' as title, avg(price) as avgPrice, sum(price) as sumPrice
from StockTickEvent(symbol='IBM').win:length(10)
where symbol='IBM'</pre><p>
					You can use aggregate functions with any type of event property or expression, with the following exceptions:
				</p><div class="orderedlist"><ol type="1" compact><li><p>
							You can use <tt class="literal">sum, avg, median, stddev, avedev</tt> with numeric event properties only	
						</p></li></ol></div><p>
					Esper ignores any null values returned by the event property or expression on which the aggregate function is operating, except for the <tt class="literal">count(*)</tt> function, which counts null values as well. All aggregate functions return null if the data set contains no events, or if all events in the data set contain only null values for the aggregated expression.
				</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="eql-grouping-group-by"></a>6.6.2.&nbsp;Organizing statement results into groups: the <span class="emphasis"><em>Group-by</em></span> clause</h3></div></div><div></div></div><p>
					The <tt class="literal">group by</tt> clause is optional in all EQL statements. The <tt class="literal">group by</tt> clause divides the output of an EQL statement into groups. You can group by one or more event property names, or by the result of computed expressions. When used with aggregate functions, <tt class="literal">group by</tt> retrieves the calculations in each subgroup. You can use <tt class="literal">group by</tt> without aggregate functions, but generally that can produce confusing results.
				</p><p>
					For example, the below statement returns the total price per symbol for all stock tick events in the last 30 seconds:
				</p><pre class="programlisting">select symbol, sum(price) from StockTickEvent.win:time(30) group by symbol</pre><p>
					The syntax of the group by clause is:
				</p><pre class="synopsis">group by <span class="emphasis"><em>arregate_free_expression</em></span> [, <span class="emphasis"><em>arregate_free_expression</em></span>] [, ...]</pre><p>
					Esper places the following restrictions on expressions in the <tt class="literal">group by</tt> clause:
				</p><div class="orderedlist"><ol type="1" compact><li><p>
							Expressions in the <tt class="literal">group by</tt> cannot contain aggregate functions
						</p></li><li><p>
							Event properties that are used within aggregate functions in the <tt class="literal">select</tt> clause cannot also be used in a <tt class="literal">group by</tt> expression
						</p></li></ol></div><p>
					You can list more then one expression in the <tt class="literal">group by</tt> clause to nest groups. Once the sets are established with <tt class="literal">group by</tt> the aggregation
					functions are applied. This statement posts the median volume for all stock tick events in the last 30 seconds per symbol and tick data feed. Esper posts one event for each group to statement listeners:
				</p><pre class="programlisting">select symbol, tickDataFeed, median(volume) 
from StockTickEvent.win:time(30) 
group by symbol, tickDataFeed</pre><p>
					In the statement above the event properties in the <tt class="literal">select</tt> list (symbol, tickDataFeed) are also listed in the <tt class="literal">group by</tt> clause.
					The statement thus follows the SQL standard which prescribes that non-aggregated event properties in the <tt class="literal">select</tt> list must match the 
					<tt class="literal">group by</tt> columns.
				</p><p>
					Esper also supports statements in which one or more event properties in the <tt class="literal">select</tt> list are not listed in the <tt class="literal">group by</tt> clause.
					The statement below demonstrates this case. It calculates the standard deviation for the last 30 seconds of stock ticks aggregating by symbol and posting for 
					each event the symbol, tickDataFeed and the standard deviation on price.
				</p><pre class="programlisting">select symbol, tickDataFeed, stddev(price) from StockTickEvent.win:time(30) group by symbol</pre><p>
					The above example still aggregates the <tt class="literal">price</tt> event property based on the <tt class="literal">symbol</tt>, but produces one event per incoming event, not one 
					event per group.
				</p><p>
					Additionally, Esper supports statements in which one or more event properties in the <tt class="literal">group by</tt> clause are not listed in the <tt class="literal">select</tt> list.
					This is an example that calculates the mean deviation per <tt class="literal">symbol</tt> and <tt class="literal">tickDataFeed</tt> and posts one event per group with <tt class="literal">symbol</tt> and mean deviation of price in the generated events. Since tickDataFeed is not in the posted results, this can potentially be confusing.
				</p><pre class="programlisting">select symbol, avedev(price) 
from StockTickEvent.win:time(30) 
group by symbol, tickDataFeed</pre><p>
					Expressions are also allowed in the <tt class="literal">group by</tt> list:
				</p><pre class="programlisting">select symbol * price, count(*) from StockTickEvent.win:time(30) group by symbol * price</pre><p>
					If the <tt class="literal">group by</tt> expression resulted in a null value, the null value becomes its own group. All null values are aggregated into the same group. If you are using the <tt class="literal">count(expression)</tt> aggregate function which does not count null values, the count returns zero if only null values are encountered.								
				</p><p>
					You can use a <tt class="literal">where</tt>	clause in a statement with <tt class="literal">group by</tt>. Events that do not satisfy the conditions in the <tt class="literal">where</tt> clause are eliminated before any grouping is done. For example, the statement below posts the number of stock ticks in the last 30 seconds with a volume larger then 100, posting one event per group (symbol).
				</p><pre class="programlisting">select symbol, count(*) from StockTickEvent.win:time(30) where volume &gt; 100 group by symbol</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="eql-grouping-having"></a>6.6.3.&nbsp;Selecting groups of events: the <span class="emphasis"><em>Having</em></span> clause</h3></div></div><div></div></div><p>
					Use the <tt class="literal">having</tt> clause to pass or reject events defined by the <tt class="literal">group-by</tt> clause. The <tt class="literal">having</tt> clause sets conditions for the <tt class="literal">group by</tt> clause in the same way <tt class="literal">where</tt> sets conditions for the <tt class="literal">select</tt> clause, except <tt class="literal">where</tt> cannot include aggregate functions, while <tt class="literal">having</tt> often does.
				</p><p>
					This statement is an example of a <tt class="literal">having</tt> clause with an aggregate function. It posts the total price per symbol for the last 30 seconds of stock tick events for only those symbols in which the total price exceeds 1000. The <tt class="literal">having</tt> clause eliminates all symbols where the total price is equal or less then 1000.
				</p><pre class="programlisting">select symbol, sum(price) 
from StockTickEvent.win:time(30) 
group by symbol 
having sum(price) &gt; 1000</pre><p>
					To include more then one condition in the <tt class="literal">having</tt> clause combine the conditions with <tt class="literal">and</tt>, <tt class="literal">or</tt> or <tt class="literal">not</tt>.
					This is shown in the statement below which selects only groups with a total price greater then 1000 and an average volume less then 500.
				</p><pre class="programlisting">select symbol, sum(price), avg(volume)
from StockTickEvent.win:time(30) 
group by symbol 
having sum(price) &gt; 1000 and avg(volume) &lt; 500</pre><p>
					Esper places the following restrictions on expressions in the <tt class="literal">having</tt> clause:
				</p><div class="orderedlist"><ol type="1" compact><li><p>
							Any expressions that contain aggregate functions must also occur in the <tt class="literal">select</tt> clause
						</p></li></ol></div><p>
					A statement with the <tt class="literal">having</tt> clause should also have a <tt class="literal">group by</tt> clause. If you omit <tt class="literal">group-by</tt>, all the events not excluded
					by the <tt class="literal">where</tt> clause return as a single group. In that case <tt class="literal">having</tt> acts like a <tt class="literal">where</tt> except that <tt class="literal">having</tt> can have aggregate functions. 
				</p><p>
					The <tt class="literal">having</tt> clause can also be used without <tt class="literal">group by</tt> clause as the below example shows. The example below posts events where the price is less then the current running average price of all stock tick events in the last 30 seconds.
				</p><pre class="programlisting">select symbol, price, avg(price) 
from StockTickEvent.win:time(30) 
having price &lt; avg(price)</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="eql-filter-where-grouping-having-interactions"></a>6.6.4.&nbsp;How the stream filter, <span class="emphasis"><em>Where</em></span>, <span class="emphasis"><em>Group By</em></span> and <span class="emphasis"><em>Having</em></span> clauses interact</h3></div></div><div></div></div><p>
					When you include filters, the <tt class="literal">where</tt> condition, the <tt class="literal">group by</tt> clause and the <tt class="literal">having</tt> condition in an EQL statement
					the sequence in which each clause affects events determines the final result:
				</p><div class="orderedlist"><ol type="1" compact><li><p>
							The event stream's filter condition, if present, dictates which events enter a window (if one is used). The filter discards any events not meeting filter criteria.
						</p></li><li><p>
							The <tt class="literal">where</tt> clause excludes events that do not meet its search condition.
						</p></li><li><p>
							Aggregate functions in the select list calculate summary values for each group.
						</p></li><li><p>
							The <tt class="literal">having</tt> clause excludes events from the final results that do not meet its search condition.
						</p></li></ol></div><p>
					The following query illustrates the use of filter, <tt class="literal">where</tt>, <tt class="literal">group by</tt> and <tt class="literal">having</tt> clauses in one statement with 
					a <tt class="literal">select</tt> clause containing an aggregate function.
				</p><pre class="programlisting">select tickDataFeed, stddev(price)
from StockTickEvent(symbol='IBM').win:length(10) 
where volume &gt; 1000
group by tickDataFeed 
having stddev(price) &gt; 0.8</pre><p>
					Esper filters events using the filter criteria for the event stream <tt class="literal">StockTickEvent</tt>. In the example above only events with symbol IBM enter the length window over the last 10 events, all other events are simply discarded. The <tt class="literal">where</tt> clause removes any events posted by the length window (events entering the window and event leaving the window) that do not match the condition of volume greater then 1000. Remaining events are applied to the <tt class="literal">stddev</tt> standard deviation aggregate function for each tick data feed as specified in the <tt class="literal">group by</tt> clause. Each <tt class="literal">tickDataFeed</tt> value generates one event. Esper applies the <tt class="literal">having</tt> clause and only lets events pass for <tt class="literal">tickDataFeed</tt> groups with a standard deviation of price greater then 0.8.
				</p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="eql-output-rate"></a>6.7.&nbsp;Stabilizing and Limiting Output: the <span class="emphasis"><em>Output</em></span> Clause</h2></div></div><div></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="eql-output-options"></a>6.7.1.&nbsp;Output Clause Options</h3></div></div><div></div></div><p>
				The <tt class="literal">output</tt> clause is optional in Esper and is used to stabilize the rate at which events are output. For example, the following statement batches old and new events and outputs them at the end of every 90 second interval.				
				</p><pre class="programlisting">select * from StockTickEvent.win:length(5) output every 90 seconds</pre><p>
					Here is the syntax for output rate limiting: 
				</p><pre class="synopsis">output [all | last] every <span class="emphasis"><em>number</em></span> [minutes | seconds | events]</pre><p>
					The optional <tt class="literal">last</tt> keyword specifies to only output the very last event, while the <tt class="literal">all</tt> keyword is the default and specifies to output all events
					in a batch. The batch size can be specified in terms of time or number of events.
				</p><p>
					The time interval can also be specified in terms of minutes; the following statement is identical to the first one.
				</p><pre class="programlisting">select * from StockTickEvent.win:length(5) output every 1.5 minutes</pre><p>
					A second way that output can be stabilized is by batching events until a certain number of events have been collected. The next statement only outputs when either 5 (or more) new or 5 (or more) old events have been batched.
				</p><pre class="programlisting">select * from StockTickEvent.win:time(30) output every 5 events</pre><p>
					Additionally, event output can be further modified by the optional last keyword, which causes output of only the last event to arrive into an output batch.
				</p><pre class="programlisting">select * from StockTickEvent.win:time(30) output last every 5 events</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="eql-output-groupby"></a>6.7.2.&nbsp;Group By, Having and Output clause interaction</h3></div></div><div></div></div><p>
					The <tt class="literal">output</tt> clause interacts in two ways with the <tt class="literal">group by</tt> and <tt class="literal">having</tt> clauses. First, in the <tt class="literal">output every n events </tt>case, the number <tt class="literal">n</tt> refers to the number of events arriving into the <tt class="literal">group by clause</tt>. That is, if the <tt class="literal">group by</tt> clause outputs only 1 event per group, or if the arriving events don't satisfy the <tt class="literal">having</tt> clause, then the actual number of events output by the statement could be fewer than <tt class="literal">n</tt>.
				</p><p>
Second, the <tt class="literal">last</tt> and <tt class="literal">all</tt> keywords have special meanings when used in a statement with aggregate functions and the <tt class="literal">group by</tt> clause. The <tt class="literal">last</tt> keyword specifies that only groups whose aggregate values have been updated with the most recent batch of events should be output. The <tt class="literal">all</tt> keyword (the default) specifies that the most recent data for all groups seen so far should be output, whether or not these groups' aggregate values have just been updated.
				</p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="eql-single-row-function-ref"></a>6.8.&nbsp;Single-row function reference</h2></div></div><div></div></div><p>
			Single-row functions return a single value for every single event result row generated by your statement. These functions can appear in the <tt class="literal">select</tt> clause,
			in the <tt class="literal">where</tt> clause and in the <tt class="literal">having</tt> clause.
		</p><p>
			The below table outlines the single-row functions available.
		</p><div class="table"><a name="eql-single-row-func"></a><p class="title"><b>Table&nbsp;6.2.&nbsp;Syntax and results of single-row functions</b></p><table summary="Syntax and results of single-row functions" border="1"><colgroup><col><col></colgroup><thead><tr><th>Single-row Function</th><th>Result</th></tr></thead><tbody><tr><td>max(<span class="emphasis"><em>expression</em></span>, <span class="emphasis"><em>expression</em></span>, [, <span class="emphasis"><em>expression</em></span> [,...]])</td><td><p>
								Returns the highest numeric value among the 2 or more comma-separated expressions.
							</p></td></tr><tr><td>min(<span class="emphasis"><em>expression</em></span>, <span class="emphasis"><em>expression</em></span>, [, <span class="emphasis"><em>expression</em></span> [,...]])</td><td><p>
								Returns the lowest numeric value among the 2 or more comma-separated expressions.
							</p></td></tr></tbody></table></div><p>
            An example showing the use of the <tt class="literal">min</tt> single-row function is below.
        </p><pre class="programlisting">select symbol, min(ticks.timestamp, news.timestamp) as minT
from StockTickEvent.win:time(30) as ticks, 
     NewsEvent.win:time(30) as news
where ticks.symbol = news.symbol
</pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="built-in-views"></a>6.9.&nbsp;Build-in views</h2></div></div><div></div></div><p>
            This chapter outlines the views that are built into Esper.
        </p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="win-views"></a>6.9.1.&nbsp;Window views</h3></div></div><div></div></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="view-win-length"></a>6.9.1.1.&nbsp;Length window</h4></div></div><div></div></div><p>
					Creates a moving window extending the specified number of elements into the past. 
				</p><p>
					The below example calculates basic univariate statistics for the last 5 stock ticks for symbol IBM.
				</p><pre class="programlisting">StockTickEvent(symbol='IBM').win:length(5).stat:uni('price')</pre><p>
					The next example keeps a length window of 10 events of stock trade events, with a separate window for each symbol. The
					statistics on price is calculated only for the last 10 events for each symbol.
				</p><pre class="programlisting">StockTickEvent.std:groupby('symbol').win:length(10).stat:uni('price')</pre></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="view-win-time"></a>6.9.1.2.&nbsp;Time window</h4></div></div><div></div></div><p>
					The time_window creates a moving time window extending from the specified time interval in seconds into the past based on the system time.
				</p><p>
					For the IBM stock tick events in the last 1000 milliseconds, calculate statistics on price.
				</p><pre class="programlisting">StockTickEvent(symbol='IBM').win:time(1).stat:uni('price')</pre></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="view-win-ext_time"></a>6.9.1.3.&nbsp;Externally-timed window</h4></div></div><div></div></div><p>
					Similar to the time window this view moving time window extending from the specified time interval in seconds into the past, but based on the millisecond
					time value supplied by an event property.
				</p><p>
					This view holds stock tick events of the last 10 seconds based on the timestamp property in <tt class="literal">StockTickEvent</tt>.
				</p><pre class="programlisting">StockTickEvent.win:ext_timed(10, 'timestamp')</pre></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="view-win-time-batch"></a>6.9.1.4.&nbsp;Time window buffer</h4></div></div><div></div></div><p>
					This window view buffers events and releases them every specified time interval in one update. 
				</p><p>
					The below example batches events into a 5 second window releasing new batches every 5 seconds. Listeners to updates
					posted by this view receive updated information only every 5 seconds.
				</p><pre class="programlisting">StockTickEvent.win:time_batch(5)</pre></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="std-views"></a>6.9.2.&nbsp;Standard view set</h3></div></div><div></div></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="view-std-unique"></a>6.9.2.1.&nbsp;Unique</h4></div></div><div></div></div><p>
					The <tt class="literal">unique</tt>view is a view that includes only the most recent among events having the same value for the specified field. 
				</p><p>
					The below example creates a view that retains only the last event per symbol.
				</p><pre class="programlisting">StockTickEvent.std:unique('symbol')</pre></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="view-std-groupby"></a>6.9.2.2.&nbsp;Group By</h4></div></div><div></div></div><p>
					This view groups events into sub-views by the value of the specified field.
				</p><p>
					This example calculates statistics on price separately for each symbol.					
				</p><pre class="programlisting">StockTickEvent.std:groupby('symbol').stat:uni('price')</pre><p>
					The next example keeps a length window of 10 events of stock trade events, with a separate window for each symbol. Now the
					statistics on price is calculated only for the last 10 events for each symbol.
				</p><pre class="programlisting">StockTickEvent.std:groupby('symbol').win:length(10).stat:uni('price')</pre></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="view-std-size"></a>6.9.2.3.&nbsp;Size</h4></div></div><div></div></div><p>
					This view returns the number of elements in view.
				</p><p>
					This example view reports the number of events within the last 1 minute.
				</p><pre class="programlisting">StockTickEvent.win:time(60000).std:size()</pre></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="view-std-last"></a>6.9.2.4.&nbsp;Last</h4></div></div><div></div></div><p>
					This view exposes the last element of its parent view.
				</p><p>
					This example view retains statistics calculated on stock tick price for the symbol IBM.
				</p><pre class="programlisting">StockTickEvent(symbol='IBM').stat:uni('price').std:lastevent()</pre></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="stat-views"></a>6.9.3.&nbsp;Statistics views</h3></div></div><div></div></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="view-stat-uni"></a>6.9.3.1.&nbsp;Univariate statistics</h4></div></div><div></div></div><p>
					This view calculated basic univariate statistics on an event property.
				</p><div class="table"><a name="view-stat-uni-table"></a><p class="title"><b>Table&nbsp;6.3.&nbsp;Univariate statistics derived properties</b></p><table summary="Univariate statistics derived properties" border="1"><colgroup><col><col></colgroup><thead><tr><th>Property Name</th><th>Description</th></tr></thead><tbody><tr><td><tt class="literal">count</tt></td><td>Number of values</td></tr><tr><td><tt class="literal">sum</tt></td><td>Sum of values</td></tr><tr><td><tt class="literal">average</tt></td><td>Average of values</td></tr><tr><td><tt class="literal">variance</tt></td><td>Variance</td></tr><tr><td><tt class="literal">stdev</tt></td><td>Sample standard deviation (square root of variance) </td></tr><tr><td><tt class="literal">stdevpa</tt></td><td>Population standard deviation</td></tr></tbody></table></div><p>
					The below example calculates price statistics on stock tick events for the last 10 events.
				</p><pre class="programlisting">StockTickEvent.win:length(10).stat:uni('price')</pre></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="view-stat-linest"></a>6.9.3.2.&nbsp;Regression</h4></div></div><div></div></div><p>
					This view calculates regression on two event properties.
				</p><div class="table"><a name="view-stat-linest-table"></a><p class="title"><b>Table&nbsp;6.4.&nbsp;Regression derived properties</b></p><table summary="Regression derived properties" border="1"><colgroup><col><col></colgroup><thead><tr><th>Property Name</th><th>Description</th></tr></thead><tbody><tr><td><tt class="literal">slope</tt></td><td>Slope</td></tr><tr><td><tt class="literal">yintercept</tt></td><td>Y Intercept</td></tr></tbody></table></div><p>
					Calculate slope and y-intercept on price and offer for all events in the last 10 seconds.
				</p><pre class="programlisting">StockTickEvent.win:time(10000).stat:linest('price', 'offer')</pre></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="view-stat-correl"></a>6.9.3.3.&nbsp;Correlation</h4></div></div><div></div></div><p>
					This view calculates the correlation value on two event properties.
				</p><div class="table"><a name="view-stat-correl-table"></a><p class="title"><b>Table&nbsp;6.5.&nbsp;Correlation derived properties</b></p><table summary="Correlation derived properties" border="1"><colgroup><col><col></colgroup><thead><tr><th>Property Name</th><th>Description</th></tr></thead><tbody><tr><td><tt class="literal">correl</tt></td><td>Correlation between two event properties</td></tr></tbody></table></div><p>
					Calculate correlation on price and offer over all stock tick events for IBM.
				</p><pre class="programlisting">StockTickEvent(symbol='IBM').stat:correl('price', 'offer')</pre></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="view-stat-weightedavg"></a>6.9.3.4.&nbsp;Weighted average</h4></div></div><div></div></div><p>
					This view returns the weighted average given a weight field and a field to compute the average for.
					Syntax: weighted_avg(field, weightField)
				</p><div class="table"><a name="view-stat-weightedavg-table"></a><p class="title"><b>Table&nbsp;6.6.&nbsp;Weighted average derived properties</b></p><table summary="Weighted average derived properties" border="1"><colgroup><col><col></colgroup><thead><tr><th>Property Name</th><th>Description</th></tr></thead><tbody><tr><td><tt class="literal">average</tt></td><td>Weighted average</td></tr></tbody></table></div><p>
					Views that derive the volume-weighted average price for the last 3 seconds.
				</p><pre class="programlisting">StockTickEvent(symbol='IBM').win:time(3000).stat:weighted_avg('price', 'volume')</pre></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="view-stat-multidim"></a>6.9.3.5.&nbsp;Multi-dimensional statistics</h4></div></div><div></div></div><p>
					This view works similar to the <tt class="literal">std:groupby</tt> views in that it groups information by one or more event properties. 
					The view accepts 3 or more parameters: The first parameter to the view defines the univariate statistics values to derive.
					The second parameter is the property name to derive data from.
					The remaining parameters supply the event property names to use to derive dimensions.
				</p><div class="table"><a name="view-stat-multidim-table"></a><p class="title"><b>Table&nbsp;6.7.&nbsp;Multi-dim derived properties</b></p><table summary="Multi-dim derived properties" border="1"><colgroup><col><col></colgroup><thead><tr><th>Property Name</th><th>Description</th></tr></thead><tbody><tr><td><tt class="literal">cube</tt></td><td>The cube following the <tt class="literal"></tt> interface</td></tr></tbody></table></div><p>
					The example below derives the count, average and standard deviation latency of service measurement events per customer.
				</p><pre class="programlisting">ServiceMeasurement.stat:multidim_stats({&#8216;count&#8217;, &#8216;average&#8217;, &#8216;stdev&#8217;}, 
    'latency', 'customer')</pre><p>
					This example derives the average latency of service measurement events per customer, service and error status for events in
					the last 30 seconds.
				</p><pre class="programlisting">ServiceMeasurement.win:length(30000).stat:multidim_stats({&#8216;average&#8217;}, 
	'latency', 'customer', 'service', 'status')</pre></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="ext-views"></a>6.9.4.&nbsp;Extension View Set</h3></div></div><div></div></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="view-ext-sort"></a>6.9.4.1.&nbsp;Sorted Window View</h4></div></div><div></div></div><p>					
					This view sorts by values in the specified event property and keeps only the top elements up to the given size. 
				</p><p>
					The syntax for this view is : <tt class="literal">sort(String propertyName, boolean isDescending, int size) </tt>.
				</p><p>
					These view can be used to sort on price descending keeping the lowest 10 prices and reporting statistics on price.
				</p><pre class="programlisting">StockTickEvent.ext:sort('price', true, 10).stat:uni('price'))</pre></div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="eql-join"></a>6.10.&nbsp;Joining Event Streams</h2></div></div><div></div></div><p>
			Two or more event streams can be part of the <tt class="literal">from</tt> clause and thus both streams determine the resulting events. The where-clause lists the join conditions that Esper uses to relate events in the two or more streams.
		</p><p>
			Each point in time that an event arrives to one of the event streams, the two event streams are joined and output events are produced according to the where-clause.
		</p><p>
			This example joins 2 event streams. The first event stream consists of fraud warning events for which we keep the last 30 minutes (1800 seconds). The second stream is withdrawal events for which we consider the last 30 seconds. The streams are joined on account number.
		</p><pre class="programlisting">select fraud.accountNumber as accntNum, fraud.warning as warn, withdraw.amount as amount,
       max(fraud.timestamp, withdraw.timestamp) as timestamp, 'withdrawlFraud' as desc
  from net.esper.example.atm.FraudWarningEvent.win:time(1800) as fraud,
       net.esper.example.atm.WithdrawalEvent.win:time(30) as withdraw
 where fraud.accountNumber = withdraw.accountNumber</pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="eql-outerjoin"></a>6.11.&nbsp;Outer Join</h2></div></div><div></div></div><p>
			Esper supports left outer joins, right outer joins and full outer joins between an unlimited number of event streams.
		</p><p>
			If the outer join is a left outer join, there will be an output event for each event of the stream on the left-hand side of the clause. For example, in the left outer join shown below we will get output for each event in the stream RfidEvent, even if the event does not match any event in the event stream OrderList.
		</p><pre class="programlisting">select * from net.esper.example.rfid.RfidEvent.win:time(30) as rfid
       left outer join
       net.esper.example.rfid.OrderList.win:length(10000) as orderlist
     on rfid.itemId = orderList.itemId</pre><p>
			Similarly, if the join is a Right Outer Join, then there will be an output event for each event of the stream on the right-hand side of the clause. For example, in the right outer join shown below we will get output for each event in the stream OrderList, even if the event does not match any event in the event stream RfidEvent.
		</p><pre class="programlisting">select * from net.esper.example.rfid.RfidEvent.win:time(30) as rfid
       right outer join
       net.esper.example.rfid.OrderList.win:length(10000) as orderlist
     on rfid.itemId = orderList.itemId</pre><p>
			For all types of outer joins, if the join condition is not met, the select list is computed with the event properties of the arrived event while all other event properties are considered to be null.
		</p><pre class="programlisting">select * from net.esper.example.rfid.RfidEvent.win:time(30) as rfid
       full outer join
       net.esper.example.rfid.OrderList.win:length(10000) as orderlist
     on rfid.itemId = orderList.itemId</pre><p>
			The last type of outer join is a full outer join. In a full outer join, each point in time that an event arrives to one of the event streams, one or more output events are produced. In the example below, when either an RfidEvent or an OrderList event arrive, one or more output event is produced.
		</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="view-adding-views"></a>6.12.&nbsp;View Plug-in</h2></div></div><div></div></div><p>
            This is currently not supported (planned).
        </p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="Adapters"></a>Chapter&nbsp;7.&nbsp;Adapters</h2></div></div><div></div></div><p>
        This chapter discusses adapters (TODO)
    </p><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="adapter-intro"></a>7.1.&nbsp;Adapter</h2></div></div><div></div></div><p>
            Adapters adapt event executions in the outside world into a format for processing by Esper, and feed events to Esper.
        </p><p>
            Currently there are no pre-build adapters available for Esper.
        </p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="Indicators"></a>Chapter&nbsp;8.&nbsp;Indicators</h2></div></div><div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="indicators-intro"></a>8.1.&nbsp;Intro</h2></div></div><div></div></div><p>
			Indicators are pluggable modules that communicate the results of event stream processing to the external world. 
			Indicators can act as visualizers that present a graphical view of their event inputs. They can also be warning agents
			(monitors) that send alerts, warnings or other control events to the outside world. 
		</p><p>
			In their implementation indicators can be classes that implement the <tt class="literal">UpdateListener</tt> interface and that can thus
			be attached directly to one or more statements. Indicactors can also be attached to one or more <tt class="literal">EPStatement</tt> instances.
			This makes is possible for indicators to merge data as well as pull data from trigger and statement views.
		</p><p>
			Indicators may be integration components that plug together with other software, an some indicators will be supplied by Esper.
			Esper currently only has one indicator module as described below.
		</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="indicators-jmx"></a>8.2.&nbsp;JMX Indicator</h2></div></div><div></div></div><p>
			The <tt class="literal">net.esper.indicator.jmx.JMXLastEventIndicator</tt> displays the last event in a JMX MBean it registers with the
			MBeanServer obtained via ManagementFactory.getPlatformMBeanServer();
		</p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="examples"></a>Chapter&nbsp;9.&nbsp;Examples</h2></div></div><div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="examples-overview"></a>9.1.&nbsp;Examples Overview</h2></div></div><div></div></div><p>
			This chapters outlines the examples that come with Esper in the <tt class="literal">eg/src</tt> folder of the distribution. The code for examples can be found in the <tt class="literal">net.esper.example</tt> packages.
		</p><p>
			In order to compile and run the samples please follow the below instructions:
		</p><div class="orderedlist"><ol type="1"><li><p>
                    Make sure Java 1.5 or greater is installed and the JAVA_HOME environment variable is set.
                </p></li><li><p>
                    Open a console window and change directory to esper/eg/etc.
                </p></li><li><p>
                    Run "setenv.bat" (Windows) or "setenv.sh" (Unix) to verify your environment settings.
                </p></li><li><p>
                    Run "compile.bat" (Windows) or "compile.sh" (Unix) to compile the examples.
                </p></li><li><p>
                    Now you are ready to run the examples. Some examples require mandatory parameters. Further information to running
                    each example can be found in "readme.txt".
                </p></li><li><p>
                    Modify the logger logging level in the "log4j.xml" configuration file 
                    changing DEBUG to INFO on a class or package level to reduce the volume of text output. 
                </p></li></ol></div><p>
			JUnit tests exist for the example code. The JUnit test source code for the examples can be found in the <tt class="literal">eg/test</tt> folder. To build and run the example JUnit tests, use the Maven 2 goal <tt class="literal">test</tt>. The JUnit test source code can also be helpful in understanding the example and in the use of Esper APIs.
		</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="examples-transaction-3-event-challenge"></a>9.2.&nbsp;Transaction 3-Event Challenge</h2></div></div><div></div></div><p>
			The classes for this example live in package <tt class="literal">net.esper.example.transaction</tt>. 
			Run "run_txnsim.bat" (Windows) or "run_txnsim.sh" (Unix) to start the transaction simulator. 
			Please see the readme file in the same folder for build instructions and command line parameters.
		</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="examples-txn3event-1"></a>9.2.1.&nbsp;The Events</h3></div></div><div></div></div><p>
	The use case involves tracking three components of a transaction. It&#8216;s important that we use at least three components, since some engines have different performance or coding for only two events per transaction. Each component comes to the engine as an event with the following fields:
			</p><div class="itemizedlist"><ul type="disc" compact><li><p>
						Transaction ID
					</p></li><li><p>
						Time stamp
					</p></li></ul></div><p>
				In addition, we have the following extra fields:
			</p><p>
				In event A:
			</p><div class="itemizedlist"><ul type="disc" compact><li><p>
						Customer ID
					</p></li></ul></div><p>
				In event C:
			</p><div class="itemizedlist"><ul type="disc" compact><li><p>
						Supplier ID (the ID of the supplier that the order was filled through)
					</p></li></ul></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="examples-txn3event-2"></a>9.2.2.&nbsp;Combined event</h3></div></div><div></div></div><p>
					We need to take in events A, B and C and produce a single, combined event with the following fields:
			</p><div class="itemizedlist"><ul type="disc" compact><li><p>
						Transaction ID
					</p></li><li><p>
						Customer ID
					</p></li><li><p>
						Time stamp from event A
					</p></li><li><p>
						Time stamp from event B
					</p></li><li><p>
						Time stamp from event C
					</p></li></ul></div><p>
What we&#8216;re doing here is matching the transaction IDs on each event, to form an aggregate event. If all these events were in a relational database, this could be done as a simple SQL join&#8230; except that with 10,000 events per second, you will need some serious database hardware to do it.
			</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="examples-txn3event-3"></a>9.2.3.&nbsp;Real time summary data</h3></div></div><div></div></div><p>
Further, we need to produce the following:
			</p><div class="itemizedlist"><ul type="disc" compact><li><p>
						Min,Max,Average total latency from the events (difference in time between A and C) over the past 30 minutes.
					</p></li><li><p>
						Min,Max,Average latency grouped by (a) customer ID and (b) supplier ID. In other words, metrics on the the latency of the orders coming from each customer and going to each supplier.
					</p></li><li><p>
						Min,Max,Average latency between events A/B (time stamp of B minus A) and B/C (time stamp of C minus B).
					</p></li></ul></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="examples-txn3event-4"></a>9.2.4.&nbsp;Find problems</h3></div></div><div></div></div><p>
We need to detect a transaction that did not make it through all three events. In other words, a transaction with events A or B, but not C. Note that, in this case, what we care about is event C. The lack of events A or B could indicate a failure in the event transport and should be ignored. Although the lack of an event C could also be a transport failure, it merits looking into.
			</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="examples-txn3event-5"></a>9.2.5.&nbsp;Event generator</h3></div></div><div></div></div><p>
To make testing easier, standard and to demonstrate how the example works, the example is including an event generator. The generator generates events for a given number of transactions, using the following rules:
			</p><div class="itemizedlist"><ul type="disc" compact><li><p>
						One in 5,000 transactions will skip event A
					</p></li><li><p>
						One in 1,000 transactions will skip event B
					</p></li><li><p>
						One in 10,000 transactions will skip event C.
					</p></li><li><p>
						Transaction identifiers are randomly generated
					</p></li><li><p>
						Customer and supplier identifiers are randomly chosen from two lists
					</p></li><li><p>
						The time stamp on each event is based on the system time. Between events A and B as well as B and C, between 0 and 999 is added to the time. So, we have an expected time difference of around 500 milliseconds between each event
					</p></li><li><p>
						Events are randomly shuffled as described below
					</p></li></ul></div><p>
	To make things harder, we don&#8216;t want transaction events coming in order. This code ensures that they come completely out of order. To do this, we fill in a bucket with events and, when the bucket is full, we shuffle it. The buckets are sized so that some transactions&#8216; events will be split between buckets. So, you have a fairly randomized flow of events, representing the worst case from a big, distributed infrastructure.
				</p><p>
	The generator lets you change the size of the bucket (small, medium, large, larger, largerer). The larger the bucket size, the more events potentially come in between two events in a given transaction and so, the more the performance characteristics like buffers, hashes/indexes and other structures are put to the test as the bucket size increases.
				</p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="examples-stockticker"></a>9.3.&nbsp;StockTicker</h2></div></div><div></div></div><p>
			 The StockTicker example comes from the stock trading domain. The example creates event patterns to filter stock tick events based on price and symbol. 
			 When a stock tick event is encountered that falls outside the lower or upper price limit, the example simply displays that stock tick event.
			 The price range itself is dynamically created and changed. This is accomplished by an event patterns that searches for another event class, the price limit event.			 			 
		</p><p>
			The classes <tt class="literal">net.esper.example.stockticker.event.StockTick</tt> and <tt class="literal">PriceLimit</tt> represent our events. The event patterns are created by the class <tt class="literal">net.esper.example.stockticker.monitor.StockTickerMonitor</tt>. 
		</p><p>
			Summary:
		</p><div class="itemizedlist"><ul type="disc" compact><li><p>
                    Good example to learn the API and get started with event patterns
                </p></li><li><p>
                    Dynamically creates and removes event patterns based on price limit events received
                </p></li><li><p>
                    Simple, highly-performant filter expressions for event properties in the stock tick event such as symbol and price
                </p></li></ul></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="examples-matchmaker"></a>9.4.&nbsp;MatchMaker</h2></div></div><div></div></div><p>
			 In the MatchMaker example every mobile user has an X and Y location, a set of properties (gender, hair color, age range) and a set of preferences (one for each property) to match. The task of the event patterns created by this example is to detect mobile users that are within proximity given a certain range, and for which the properties match preferences.
		</p><p>
			The event class representing mobile users is <tt class="literal">net.esper.example.matchmaker.event.MobileUserBean</tt>. The <tt class="literal">net.esper.example.matchmaker.monitor.MatchMakingMonitor</tt> class contains the patterns for detecing matches.
		</p><p>
			Summary:
		</p><div class="itemizedlist"><ul type="disc" compact><li><p>
                    Dynamically creates and removes event patterns based on mobile user events received
                </p></li><li><p>
                    Uses range matching for X and Y properties of mobile user events
                </p></li></ul></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="examples-qossla"></a>9.5.&nbsp;QualityOfService</h2></div></div><div></div></div><p>
            This example develops some code for measuring quality-of-service levels such as for a service-level agreement (SLA).
            A SLA is a contract between 2 parties that defines service constraints such as maximum latency for service operations or error rates.
        </p><p>                      
            The example measures and monitors operation latency and error counts per customer and operation. When 
            one of our operations oversteps these constraints, we want to be alerted right away. Additionally, we would like to have some monitoring in
            place that checks the health of our service and provides some information on how the operations are used.
        </p><p>                      
            Some of the constraints we need to check are:
         </p><div class="itemizedlist"><ul type="disc" compact><li><p>
					That the latency (time to finish) of some of the operations is always less then X seconds.
				</p></li><li><p>
					That the latency average is always less then Y seconds over Z operation invocations. 
				</p></li></ul></div><p>
			The <tt class="literal">net.esper.example.qos_sla.events.OperationMeasurement</tt> event class with its latency and status properties is the main event used for the SLA analysis. The other event <tt class="literal">LatencyLimit</tt> serves to set latency limits on the fly.
		</p><p>
			The <tt class="literal">net.esper.example.qos_sla.monitor.AverageLatencyMonitor</tt> creates an EQL statement that computes latency statistics per customer and operation for the
			last 100 events. The <tt class="literal">DynaLatencySpikeMonitor</tt> uses an event pattern to listen to spikes in latency with dynamically set limits. The <tt class="literal">ErrorRateMonitor</tt> uses the timer <tt class="literal">'at'</tt> operator in an event pattern that wakes up periodically and polls the error rate within the last 10 minutes. The <tt class="literal">ServiceHealthMonitor</tt> simply alerts when 3 errors occur, and the <tt class="literal">SpikeAndErrorMonitor</tt> alerts when a fixed latency is overstepped or an error status is reported.
		</p><p>
			Summary:
		</p><div class="itemizedlist"><ul type="disc" compact><li><p>
                    This example combines event patterns with EQL statements for event stream analysis.
                </p></li><li><p>
                    Shows the use of the timer <tt class="literal">'at'</tt> operator and followed-by operator <tt class="literal">-&gt;</tt> in event patterns
                </p></li><li><p>
                    Outlines basic EQL statements
                </p></li><li><p>
                    Shows how to pull data out of EQL statements rather then subscribing to events a statement publishes
                </p></li></ul></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="examples-linearroad"></a>9.6.&nbsp;LinearRoad</h2></div></div><div></div></div><p>
			The Linear Road example is a very incomplete implementation of the Stream Data Management Benchmark [3] by Standford University. 
        </p><p>
			Linear Road simulates a toll system for the motor vehicle expressways of a large metropolitan area. The main event in this example is a car location report which the class
			<tt class="literal">net.esper.example.linearroad.CarLocEvent</tt> represents. Currently the event stream joins are performed by JUnit test classes in the <tt class="literal">eg/test</tt> folder. See the <tt class="literal">net.esper.example.linearroad.TestAccidentNotify</tt> and the <tt class="literal">TestCarSegmentCount</tt> classes. Please consider this a work in progress.
        </p><p>
			Summary:
		</p><div class="itemizedlist"><ul type="disc" compact><li><p>
                    Shows more complex joins between event streams.
                </p></li></ul></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="examples-stocktick-rsi"></a>9.7.&nbsp;StockTick RSI</h2></div></div><div></div></div><p>
			The RSI gives you the trend for a stock and for more complete explanation, you can visit the link: http://www.stockcharts.com/education/IndicatorAnalysis/indic_RSI.html.
		</p><p>
			After a definite number of stock events, or accumulation period, the first RSI is computed. Then for each subsequent stock event, the RSI calculations use the previous period&#8217;s Average Gain and Loss to determine the &#8220;smoothed RSI&#8221;.
        </p><p>
			Summary:
		</p><div class="itemizedlist"><ul type="disc" compact><li><p>
                    Uses a simple event pattern with a filter which feeds a listener that computes the RSI, which publishes events containing the computed RSI.
                </p></li></ul></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="references"></a>Chapter&nbsp;10.&nbsp;References</h2></div></div><div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="references-listing"></a>10.1.&nbsp;Reference List</h2></div></div><div></div></div><div class="itemizedlist"><ul type="disc" compact><li><p>
					Luckham, David. 2002. <span class="emphasis"><em>The Power of Events.</em></span> Addison-Wesley.
				</p></li><li><p>
					The Stanford Rapide (TM) Project. <span class="emphasis"><em>http://pavg.stanford.edu/rapide</em></span>.
				</p></li><li><p>
					Arasu, Arvind, et.al.. 2004. Linear Road: A Stream Data Management Benchmark, Stanford University <span class="emphasis"><em>http://www.cs.brown.edu/research/aurora/Linear_Road_Benchmark_Homepage.html</em></span>.
				</p></li></ul></div></div></div></div></body></html>